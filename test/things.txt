index=notable mc_incident_id=*
| eval _entity=lower("$tok_entity$"), _etype="$tok_etype$"
| eval _m_user=lower(coalesce(user, src_user, dest_user, Account_Name, user_name, identity))
| eval _m_host=lower(coalesce(host, dest, dvc, dest_nt_host, src_nt_host))
| eval _m_ip=coalesce(src, dest, src_ip, dest_ip)
| eval _m_mail=lower(coalesce(user_email, src_user_email, dest_user_email, recipient, sender))
| eval _m_dom=lower(coalesce(url_domain, query, dest_dns, domain))
| eval _m_url=lower(coalesce(url, uri, request))
| eval _m_hash=lower(coalesce(file_hash, sha256, sha1, md5))
| eval _m_risk=lower(risk_object)
| eval _match=case(
    _etype="user", _m_user=_entity,
    _etype="ip", cidrmatch(_entity, _m_ip) OR _m_ip=_entity,
    _etype="host", _m_host=_entity,
    _etype="email", _m_mail=_entity,
    _etype="domain", _m_dom=_entity,
    _etype="url", like(_m_url, "%" . _entity . "%"),
    _etype="hash", _m_hash=_entity,
    _etype="risk_object", _m_risk=_entity,
    true(), _m_user=_entity OR _m_host=_entity OR _m_ip=_entity OR _m_mail=_entity OR _m_dom=_entity OR like(_m_url, "%" . _entity . "%") OR _m_hash=_entity OR _m_risk=_entity
)
| where _match=1
| stats min(_time) as first_seen
        max(_time) as last_seen
        dc(rule_title) as detections
        values(rule_title) as rules
        sum(coalesce(risk_score,0)) as total_risk
        values(owner) as owners
        values(status) as statuses
        values(urgency) as urgencies
        values(mc_incident_id) as mc_ids
        by risk_object
| eval first_seen=strftime(first_seen,"%Y-%m-%d %H:%M:%S"),
       last_seen=strftime(last_seen,"%Y-%m-%d %H:%M:%S")
| eval rules=mvjoin(mvlimit(rules,5), ", "),
       owners=mvjoin(mvlimit(owners,5), ", "),
       statuses=mvjoin(mvlimit(statuses,5), ", "),
       urgencies=mvjoin(mvlimit(urgencies,5), ", "),
       mc_ids=mvjoin(mvlimit(mc_ids,5), ", ")
| sort - last_seen
| rename risk_object as "Risk Object",
         mc_ids as "MC Incident IDs",
         total_risk as "Total Risk",
         detections as "Detection Count"
| fields last_seen first_seen "Risk Object" "MC Incident IDs" "Detection Count" "Total Risk" rules owners statuses urgencies




index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| where isnotnull(geo.asn) AND isnotnull(httpMessage.host) AND match(geo.asn,"^\d+$")
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        dc(httpMessage.host) as bucket_unique_targets
        values(httpMessage.host) as bucket_hosts
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.tag) as bucket_tags
  by geo.asn _time
| eval bucket_rps=round(bucket_requests/30,0)
| sort 0 geo.asn _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval new_session=if(isnull(prev_time) OR _time-prev_time>600,1,0)
| streamstats sum(new_session) as session_id by geo.asn
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        sum(bucket_unique_ips) as unique_ips_est
        max(bucket_unique_targets) as unique_targets_est
        values(bucket_hosts) as hosts
        values(bucket_rule_ids) as rules_mv
        values(bucket_tags) as tags_mv
  by geo.asn session_id
| eval duration_sec=stop-start+30
| eval avg_rps=round(total_requests/duration_sec,0)
| eval first=strftime(start,"%Y-%m-%d %H:%M UTC")
| eval last=strftime(stop,"%Y-%m-%d %H:%M UTC")
| eval duration_min=round(duration_sec/60,0)
| eval host_mv=mvdedup(hosts)
| eval primary_targets=if(mvcount(host_mv)>2, mvjoin(mvindex(host_mv,0,1), ", ") . " (+" . tostring(mvcount(host_mv)-2,"commas") . " more)", mvjoin(host_mv,", "))
| eval rule_id_count=mvcount(mvdedup(rules_mv))
| eval tag_count=mvcount(mvdedup(tags_mv))
| where peak_rps>=20 OR total_requests>=2000
| sort - peak_rps
| eval peak_rps=tostring(peak_rps,"commas")
| eval avg_rps=tostring(avg_rps,"commas")
| eval total_requests=tostring(total_requests,"commas")
| table geo.asn first last duration_min peak_rps avg_rps total_requests unique_ips_est unique_targets_est primary_targets rule_id_count tag_count
| rename geo.asn as "ASN"
        first as "First Seen"
        last as "Last Seen"
        duration_min as "Duration (min)"
        peak_rps as "Peak RPS"
        avg_rps as "Avg RPS"
        total_requests as "Total Requests"
        unique_ips_est as "Unique IPs (est)"
        unique_targets_est as "Unique Targets (est)"
        primary_targets as "Primary Targets"
        rule_id_count as "Rule IDs (count)"
        tag_count as "Tags (count)"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| spath input=_raw path=geo.asn output=asn
| spath input=_raw path=httpMessage.host output=host
| spath input=_raw path=attackData.clientIP output=src_ip
| spath input=_raw path=attackData.rules{}.id output=rule_ids
| spath input=_raw path=attackData.rules{}.tag output=tags
| where match(asn,"^\d+$")
| bin _time span=30s
| stats count as bucket_requests
        dc(src_ip) as bucket_unique_ips
        values(host) as bucket_hosts
        values(tags) as bucket_tags
        values(rule_ids) as bucket_rule_ids
    by asn _time
| eval bucket_rps=round(bucket_requests/30,0)
| sort 0 asn _time
| streamstats current=f window=1 last(_time) as prev_time by asn
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600,1,0)
| streamstats sum(new_session) as session_id by asn
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        sum(bucket_unique_ips) as unique_ips_est
        values(bucket_hosts) as hosts
        values(bucket_tags) as tags_mv
        values(bucket_rule_ids) as rules_mv
    by asn session_id
| eval duration_sec=stop - start + 30
| eval session_min=round(duration_sec/60,0)
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        sum(duration_sec) as active_sec
        count as sessions
        sum(unique_ips_est) as unique_ips_est
        values(hosts) as all_hosts
        values(tags_mv) as all_tags
        values(rules_mv) as all_rules
        min(start) as first_seen
        max(stop) as last_seen
    by asn
| eval active_min=round(active_sec/60,0)
| eval span_min=round((last_seen - first_seen)/60,0)
| eval overall_rps=if(active_sec>0,round(total_requests_all/active_sec,0),0)
| eval host_mv=mvdedup(all_hosts)
| eval unique_targets=mvcount(host_mv)
| eval primary_targets=if(unique_targets>3,
                          mvjoin(mvindex(host_mv,0,2), ", ") . " (+" . tostring(unique_targets-3,"commas") . " more)",
                          mvjoin(host_mv,", "))
| eval rule_id_count=mvcount(mvdedup(all_rules))
| eval tag_count=mvcount(mvdedup(all_tags))
| eval first_str=strftime(first_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval total_requests_fmt=tostring(total_requests_all,"commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps,"commas")
| eval overall_rps_fmt=tostring(overall_rps,"commas")
| where max_peak_rps>=5 OR total_requests_all>=500
| sort - max_peak_rps
| table asn first_str last_str span_min active_min sessions max_peak_rps_fmt overall_rps_fmt total_requests_fmt unique_ips_est unique_targets primary_targets rule_id_count tag_count
| rename asn as "ASN"
        first_str as "First Seen"
        last_str as "Last Seen"
        span_min as "Span (min)"
        active_min as "Active (min)"
        sessions as "Sessions"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_ips_est as "Unique IPs (est)"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        rule_id_count as "Rule IDs (count)"
        tag_count as "Tags (count)"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| where isnotnull(geo.asn) AND geo.asn!="" AND lower(geo.asn)!="unknown"
  AND isnotnull(httpMessage.host) AND httpMessage.host!="" AND lower(httpMessage.host)!="unknown"
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.tag) as bucket_tags
    by geo.asn _time
| eval bucket_rps=round(bucket_requests/30,0)
| sort 0 geo.asn _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600,1,0)
| streamstats sum(new_session) as session_id by geo.asn
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        sum(bucket_unique_ips) as bucketed_unique_ips
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_rule_ids) as rule_ids
        values(bucket_tags) as tags
    by geo.asn session_id
| eval duration_sec=stop - start + 30
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        sum(duration_sec) as active_sec
        count as sessions
        values(hosts) as all_hosts
        values(countries) as countries
        values(rule_ids) as rule_ids
        values(tags) as tags
        min(start) as first_seen
        max(stop) as last_seen
    by geo.asn
| eval active_min=round(active_sec/60,0)
| eval span_min=round((last_seen - first_seen)/60,0)
| eval overall_rps=if(active_sec>0,round(total_requests_all/active_sec,0),0)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3,
                          mvjoin(mvindex(hosts_flat,0,2), ", ")." (+".tostring(unique_targets-3,"commas")." more)",
                          mvjoin(hosts_flat,", "))
| eval countries_flat=mvdedup(countries)
| eval countries_summary=if(mvcount(countries_flat)>5,
                            mvjoin(mvindex(countries_flat,0,4), ", ")." (+".tostring(mvcount(countries_flat)-5,"commas")." more)",
                            mvjoin(countries_flat,", "))
| eval rule_id_count=mvcount(mvdedup(rule_ids))
| eval tag_count=mvcount(mvdedup(tags))
| eval max_peak_rps_fmt=tostring(max_peak_rps,"commas")
| eval overall_rps_fmt=tostring(overall_rps,"commas")
| eval total_requests_fmt=tostring(total_requests_all,"commas")
| eval first_str=strftime(first_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval severity=case(max_peak_rps>=100000,"CRITICAL",
                     max_peak_rps>=10000,"HIGH",
                     max_peak_rps>=1000,"MEDIUM",
                     max_peak_rps>=100,"LOW",
                     1=1,"NORMAL")
| where max_peak_rps>=50 OR total_requests_all>=5000
| sort - max_peak_rps
| table geo.asn first_str last_str span_min active_min sessions max_peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_targets primary_targets countries_summary rule_id_count tag_count
| rename geo.asn as "ASN"
        first_str as "First Seen"
        last_str as "Last Seen"
        span_min as "Span (min)"
        active_min as "Active (min)"
        sessions as "Sessions"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"
        rule_id_count as "Rule IDs (count)"
        tag_count as "Tags (count)"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval asn=coalesce(geo.asn,"asn_unknown")
| rex field=httpMessage.requestHeaders "User-Agent:\s*(?<user_agent>[^\r\n]+)"
| eval ua_norm=lower(replace(coalesce(user_agent,"unknown_ua"),"\d+(\.\d+)*",""))
| eval ua_norm=replace(ua_norm,"[^a-z0-9]+","_")
| eval cookie_id=coalesce(httpMessage.cookies.JSESSIONID,httpMessage.cookies.SESSIONID)
| eval tls_fp=if(len(identity.tlsFingerprintV3)>0,identity.tlsFingerprintV3,null())
| eval ja3=if(len(identity.ja3Fingerprint)>0,identity.ja3Fingerprint,null())
| eval id_type=case(isnotnull(tls_fp),"TLS_FP",isnotnull(ja3),"JA3",isnotnull(cookie_id),"Cookie",1=1,"UA")
| eval id_value=case(isnotnull(tls_fp),tls_fp,isnotnull(ja3),ja3,isnotnull(cookie_id),cookie_id,1=1,ua_norm)
| eval host=coalesce(httpMessage.host,"host_unknown")
| eval corr_key=asn."|".host."|".id_type."|".id_value
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by asn host id_type id_value corr_key _time
| eval bucket_rps=round(bucket_requests/30,2)
| eventstats p95(bucket_rps) as p95 p99(bucket_rps) as p99 by corr_key
| eval spike=if(bucket_rps>=200 OR bucket_rps>=(p95*3) OR bucket_rps>=(p99*1.5),1,0)
| where spike=1
| sort 0 corr_key _time
| streamstats current=f window=1 last(_time) as prev_time by corr_key
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600,1,0)
| streamstats sum(new_session) as session_id by corr_key
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
    by asn host id_type id_value corr_key session_id
| eval session_sec=stop - start + 30
| eval session_min=round(session_sec/60,1)
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        count as sessions
        sum(session_sec) as active_sec
        avg(session_min) as avg_session_min
        max(session_min) as max_session_min
        min(start) as first_seen
        max(stop) as last_seen
        sum(unique_ips) as unique_ips_est
        values(countries) as countries
        values(tags) as tags
        values(rule_ids) as rule_ids
    by asn host id_type id_value
| eval active_min=round(active_sec/60,1)
| eval span_min=round((last_seen - first_seen)/60,1)
| eval overall_rps=if(active_sec>0,round(total_requests_all/active_sec,2),0)
| eval countries_flat=mvdedup(countries)
| eval countries_summary=if(mvcount(countries_flat)>5,mvjoin(mvindex(countries_flat,0,4),", ")." (+".tostring(mvcount(countries_flat)-5,"commas")." more)",mvjoin(countries_flat,", "))
| eval tags_flat=mvdedup(tags)
| eval tags_summary=if(mvcount(tags_flat)>5,mvjoin(mvindex(tags_flat,0,4),"; ")." (+".tostring(mvcount(tags_flat)-5,"commas")." more)",mvjoin(tags_flat,"; "))
| eval rules_flat=mvdedup(rule_ids)
| eval rules_summary=if(mvcount(rules_flat)>5,mvjoin(mvindex(rules_flat,0,4),"; ")." (+".tostring(mvcount(rules_flat)-5,"commas")." more)",mvjoin(rules_flat,"; "))
| eval severity=case(max_peak_rps>=100000,"CRITICAL",max_peak_rps>=10000,"HIGH",max_peak_rps>=1000,"MEDIUM",max_peak_rps>=100,"LOW",1=1,"NORMAL")
| eval first_str=strftime(first_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen,"%Y-%m-%d %H:%M:%S UTC")
| eval max_peak_rps_fmt=tostring(max_peak_rps,"commas")
| eval overall_rps_fmt=tostring(overall_rps,"commas")
| eval total_requests_fmt=tostring(total_requests_all,"commas")
| where max_peak_rps>=100 OR total_requests_all>=10000
| sort - max_peak_rps
| table asn host id_type id_value first_str last_str span_min active_min sessions avg_session_min max_session_min max_peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_ips_est countries_summary tags_summary rules_summary
| rename asn as "ASN"
        host as "Target Host"
        id_type as "Key Type"
        id_value as "Key Value"
        first_str as "First Seen"
        last_str as "Last Seen"
        span_min as "Span (min)"
        active_min as "Active (min)"
        sessions as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_session_min as "Max Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_ips_est as "Unique IPs (est)"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval asn=coalesce(geo.asn,"asn_unknown")
| eval fid=coalesce(identity.tlsFingerprintV3, identity.ja3Fingerprint, httpMessage.cookies.JSESSIONID, httpMessage.cookies.SESSIONID, "no_fid")
| eval key=asn + "|" + fid
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.tag) as bucket_tags
        by key httpMessage.host _time
| eval bucket_rps=round(bucket_requests/30, 2)
| stats sum(bucket_requests) as bucket_requests
        sum(bucket_unique_ips) as bucket_unique_ips
        values(httpMessage.host) as hosts
        values(bucket_countries) as countries
        values(bucket_rule_ids) as rule_ids
        values(bucket_tags) as tags
        by key _time
| eval bucket_rps=round(bucket_requests/30, 2)
| where bucket_rps>=10
| sort 0 key _time
| streamstats current=f window=1 last(_time) as prev_time by key
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by key
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        values(hosts) as all_hosts
        values(countries) as all_countries
        values(tags) as all_tags
        values(rule_ids) as all_rule_ids
        sum(bucket_unique_ips) as unique_ips_est
        by key session_id
| eval session_min=round((stop - start + 30)/60, 1)
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        count as sessions
        avg(session_min) as avg_session_min
        min(start) as first_seen
        max(stop) as last_seen
        values(all_hosts) as hosts
        values(all_countries) as countries
        values(all_tags) as tags
        values(all_rule_ids) as rule_ids
        by key
| rex field=key "^(?<asn>[^|]+)\|(?<fid>.*)$"
| eval hosts_flat=mvdedup(hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3, mvjoin(mvindex(hosts_flat,0,2), ", ") + " (+" + tostring(unique_targets-3, "commas") + " more)", mvjoin(hosts_flat, ", "))
| eval countries_flat=mvdedup(countries)
| eval countries_summary=if(mvcount(countries_flat)>5, mvjoin(mvindex(countries_flat,0,4), ", ") + " (+" + tostring(mvcount(countries_flat)-5, "commas") + " more)", mvjoin(countries_flat, ", "))
| eval tags_flat=mvdedup(tags)
| eval tags_summary=if(mvcount(tags_flat)>5, mvjoin(mvindex(tags_flat,0,4), "; ") + " (+" + tostring(mvcount(tags_flat)-5, "commas") + " more)", mvjoin(tags_flat, "; "))
| eval rule_ids_flat=mvdedup(rule_ids)
| eval rules_summary=if(mvcount(rule_ids_flat)>5, mvjoin(mvindex(rule_ids_flat,0,4), "; ") + " (+" + tostring(mvcount(rule_ids_flat)-5, "commas") + " more)", mvjoin(rule_ids_flat, "; "))
| eval span_min=round((last_seen - first_seen)/60, 1)
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps, "commas")
| where max_peak_rps>=50 OR total_requests_all>=5000
| sort - max_peak_rps
| table asn fid first_str last_str span_min sessions avg_session_min max_peak_rps_fmt total_requests_fmt unique_targets primary_targets countries_summary tags_summary rules_summary
| rename asn as "ASN"
        fid as "Correlation Key"
        first_str as "First Seen"
        last_str as "Last Seen"
        span_min as "Span (min)"
        sessions as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(identity.tlsFingerprintV3) as tls_v3
        values(identity.tlsFingerprintV2) as tls_v2
        values(identity.ja3Fingerprint) as ja3
        values(attackData.rules{}.id) as rule_ids
        values(attackData.rules{}.tag) as tags
        values(geo.country) as bucket_countries
    by geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| sort 0 geo.asn, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, httpMessage.host
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        dc(tls_v3) as tls_v3_count
        dc(tls_v2) as tls_v2_count
        dc(ja3) as ja3_count
        values(bucket_countries) as countries
        values(tags) as tags
        values(rule_ids) as rule_ids
    by geo.asn, httpMessage.host, session_id
| eval duration_min=round((stop - start + 30)/60, 1)
| eval first_seen=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval last_seen=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps, "commas")
| eval countries_summary=mvjoin(mvdedup(countries), ", ")
| eval tags_summary=mvjoin(mvsort(mvdedup(tags)), "; ")
| eval rules_summary=mvjoin(mvsort(mvdedup(rule_ids)), "; ")
| where total_requests>=100 OR peak_rps>=10
| sort - peak_rps
| table geo.asn httpMessage.host first_seen last_seen duration_min peak_rps_fmt avg_rps_fmt total_requests_fmt unique_ips tls_v3_count tls_v2_count ja3_count countries_summary tags_summary rules_summary
| rename geo.asn as "ASN"
        httpMessage.host as "Target Host"
        first_seen as "First Seen"
        last_seen as "Last Seen"
        duration_min as "Duration (min)"
        peak_rps_fmt as "Max Peak RPS"
        avg_rps_fmt as "Avg RPS"
        total_requests_fmt as "Total Requests"
        unique_ips as "Unique IPs"
        tls_v3_count as "TLSv3 FP Count"
        tls_v2_count as "TLSv2 FP Count"
        ja3_count as "JA3 Count"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval tls_v3=identity.tlsFingerprintV3, tls_v2=identity.tlsFingerprintV2, ja3=identity.ja3Fingerprint
| eval cookie_id=coalesce(httpMessage.cookies.JSESSIONID, httpMessage.cookies.SESSIONID)
| eval key_raw=coalesce(ja3, tls_v3, tls_v2, cookie_id)
| eval key=if(isnull(key_raw) OR key_raw="", geo.asn . "_" . httpMessage.host, key_raw)
| eval key=lower(replace(key, "[^a-z0-9:_-]", "_"))
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
    by key, geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as p95 p99(bucket_rps) as p99 by key, httpMessage.host
| eval spike=if(bucket_rps>=50 OR (p95>0 AND bucket_rps>=p95*3) OR (p99>0 AND bucket_rps>=p99*1.5), 1, 0)
| where spike=1
| sort 0 key, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by key, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>300, 1, 0)
| streamstats sum(new_session) as session_id by key, httpMessage.host
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_countries) as countries
    by geo.asn, httpMessage.host, key, session_id
| eval duration_sec=stop - start + 30
| eval rps=round(total_requests/duration_sec, 2)
| eval first_seen=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval last_seen=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval countries_summary=mvjoin(mvdedup(countries), ", ")
| where total_requests>=1000 AND peak_rps>=50
| sort - peak_rps
| table geo.asn httpMessage.host key first_seen last_seen duration_sec rps peak_rps total_requests unique_ips countries_summary
| rename geo.asn as "ASN"
        httpMessage.host as "Target Host"
        key as "Correlation Key"
        first_seen as "First Seen"
        last_seen as "Last Seen"
        duration_sec as "Duration (sec)"
        rps as "Avg RPS"
        peak_rps as "Max Peak RPS"
        total_requests as "Total Requests"
        unique_ips as "Unique IPs"
        countries_summary as "Countries"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval tls_v3=identity.tlsFingerprintV3, tls_v2=identity.tlsFingerprintV2, ja3=identity.ja3Fingerprint
| eval cookie_id=coalesce(httpMessage.cookies.JSESSIONID, httpMessage.cookies.SESSIONID)
| eval key_raw=coalesce(ja3, tls_v3, tls_v2, cookie_id)
| eval key=if(isnull(key_raw) OR key_raw="", geo.asn . "_" . httpMessage.host, key_raw)
| eval key=lower(replace(key, "[^a-z0-9:_-]", "_"))
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
    by key, geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as p95 p99(bucket_rps) as p99 by key, httpMessage.host
| eval spike=if(bucket_rps>=50 OR (p95>0 AND bucket_rps>=p95*3) OR (p99>0 AND bucket_rps>=p99*1.5), 1, 0)
| where spike=1
| sort 0 key, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by key, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>300, 1, 0)
| streamstats sum(new_session) as session_id by key, httpMessage.host
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_countries) as countries
    by geo.asn, httpMessage.host, key, session_id
| eval duration_sec=stop - start + 30
| eval rps=round(total_requests/duration_sec, 2)
| eval first_seen=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval last_seen=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval countries_summary=mvjoin(mvdedup(countries), ", ")
| where total_requests>=1000 AND peak_rps>=50
| sort - peak_rps
| table geo.asn httpMessage.host key first_seen last_seen duration_sec rps peak_rps total_requests unique_ips countries_summary
| rename geo.asn as "ASN"
        httpMessage.host as "Target Host"
        key as "Correlation Key"
        first_seen as "First Seen"
        last_seen as "Last Seen"
        duration_sec as "Duration (sec)"
        rps as "Avg RPS"
        peak_rps as "Max Peak RPS"
        total_requests as "Total Requests"
        unique_ips as "Unique IPs"
        countries_summary as "Countries"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval cookie_id=coalesce(httpMessage.cookies.JSESSIONID, httpMessage.cookies.SESSIONID, "nocookie")
| eval tls_fp=coalesce(identity.tlsFingerprintV3, "unknown")
| eval ja3=coalesce(identity.ja3Fingerprint, "unknown")
| eval ua_clean=lower(replace(httpMessage.requestHeaders."User-Agent", "\d+\.\d+(\.\d+)?", ""))
| eval ua_norm=replace(ua_clean, "[^a-z0-9]+", "_")
| eval fingerprint=coalesce(ja3, tls_fp, cookie_id, ua_norm)
| eval fingerprint=if(fingerprint="unknown" OR isnull(fingerprint), geo.asn . "_" . httpMessage.host, fingerprint)
| eval fingerprint=lower(fingerprint)
| eval fingerprint=replace(fingerprint, "[^a-z0-9:_-]", "_")
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as unique_ips
        values(httpMessage.host) as targets
        values(geo.country) as countries
        values(attackData.rules{}.id) as rule_ids
        values(attackData.rules{}.tag) as tags
        min(_time) as first_seen
        max(_time) as last_seen
    by fingerprint, _time
| eval bucket_rps=round(bucket_requests / 30, 2)
| eventstats p95(bucket_rps) as p95, p99(bucket_rps) as p99 by fingerprint
| eval spike=if(bucket_rps >= 1000 OR bucket_rps >= p95 * 3 OR bucket_rps >= p99 * 1.5, 1, 0)
| where spike = 1
| sort 0 fingerprint, _time
| streamstats current=f window=1 last(_time) as prev_time by fingerprint
| eval gap=if(isnull(prev_time), 0, _time - prev_time)
| eval new_session=if(gap > 300, 1, 0)
| streamstats sum(new_session) as session_id by fingerprint
| stats 
    sum(bucket_requests) as total_requests
    max(bucket_rps) as peak_rps
    min(_time) as session_start
    max(_time) as session_end
    dc(targets) as host_count
    values(targets) as target_list
    dc(countries) as country_count
    values(countries) as country_list
    dc(rule_ids) as rule_count
    values(rule_ids) as rule_ids
    values(tags) as attack_tags
    dc(unique_ips) as unique_ips
    by fingerprint, session_id
| eval session_duration_min=round((session_end - session_start) / 60, 1)
| eval rps=round(total_requests / ((session_end - session_start) + 1), 2)
| eval first_seen=strftime(session_start, "%F %H:%M")
| eval last_seen=strftime(session_end, "%F %H:%M")
| where rps > 10 AND total_requests > 1000
| sort -peak_rps
| table fingerprint, rps, peak_rps, total_requests, session_duration_min, unique_ips, host_count, country_count, first_seen, last_seen, attack_tags, rule_ids



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI earliest=-14d@d latest=now
| eval cookie_id=coalesce(httpMessage.cookies.JSESSIONID, httpMessage.cookies.SESSIONID, "nocookie")
| eval tls_fp=coalesce(identity.tlsFingerprintV3, "unknown")
| eval ja3=coalesce(identity.ja3Fingerprint, "unknown")
| eval ua_clean=lower(replace(httpMessage.requestHeaders."User-Agent", "\d+\.\d+(\.\d+)?", ""))
| eval ua_norm=replace(ua_clean, "[^a-z0-9]+", "_")
| eval fingerprint=coalesce(ja3, tls_fp, cookie_id, ua_norm, geo.asn)
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as unique_ips
        values(httpMessage.host) as targets
        values(geo.country) as countries
        values(attackData.rules{}.id) as rule_ids
        values(attackData.rules{}.tag) as tags
        min(_time) as first_seen
        max(_time) as last_seen
    by fingerprint, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as p95, p99(bucket_rps) as p99 by fingerprint
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=p95*3 OR bucket_rps>=p99*1.5,1,0)
| where spike=1
| sort 0 fingerprint, _time
| streamstats current=f window=1 last(_time) as prev_time by fingerprint
| eval gap=if(isnull(prev_time),0,_time - prev_time)
| eval new_session=if(gap>300,1,0)
| streamstats sum(new_session) as session_id by fingerprint
| stats 
    sum(bucket_requests) as total_requests
    max(bucket_rps) as peak_rps
    min(_time) as session_start
    max(_time) as session_end
    dc(targets) as host_count
    values(targets) as target_list
    dc(countries) as country_count
    values(countries) as country_list
    dc(rule_ids) as rule_count
    values(rule_ids) as rule_ids
    values(tags) as attack_tags
    dc(unique_ips) as unique_ips
    by fingerprint, session_id
| eval session_duration_min=round((session_end - session_start)/60,1)
| eval rps=round(total_requests / ((session_end - session_start) + 1), 2)
| eval first_seen=strftime(session_start, "%F %H:%M")
| eval last_seen=strftime(session_end, "%F %H:%M")
| where rps > 10 AND total_requests > 1000
| sort -peak_rps
| table fingerprint, rps, peak_rps, total_requests, session_duration_min, unique_ips, host_count, country_count, first_seen, last_seen, attack_tags, rule_ids



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| spath input=_raw path=identity.tlsFingerprintV3 output=tls_v3
| spath input=_raw path=identity.tlsFingerprintV2 output=tls_v2
| eval tls_fp=coalesce(tls_v3, tls_v2)
| eval corr_id=coalesce(tls_fp, httpMessage.host)
| bin _time span=30s
| stats count as bucket_requests
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
    by geo.asn, corr_id, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, corr_id, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, corr_id, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, corr_id, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, corr_id, httpMessage.host
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
    by geo.asn, corr_id, httpMessage.host, session_id
| eval session_sec=stop - start + 30
| eval session_min=round(session_sec/60, 1)
| fields geo.asn corr_id start stop session_sec session_min peak_rps total_requests hosts countries
| sort 0 geo.asn, corr_id, start
| streamstats max(stop) as run_max_stop by geo.asn, corr_id
| streamstats current=f window=1 last(run_max_stop) as prev_union_stop by geo.asn, corr_id
| eval add_sec=case(isnull(prev_union_stop), stop - start,
                    start>=prev_union_stop, stop - start,
                    stop>prev_union_stop, stop - prev_union_stop,
                    1=1, 0)
| streamstats sum(add_sec) as covered_sec by geo.asn, corr_id
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        count as session_count
        avg(session_min) as avg_session_min_raw
        max(session_min) as max_session_min
        min(start) as first_seen
        max(stop) as last_seen
        values(hosts) as all_hosts
        values(countries) as countries
        max(covered_sec) as covered_sec
    by geo.asn, corr_id
| eval campaign_span_min=round((last_seen - first_seen)/60, 1)
| eval active_min=round(covered_sec/60, 1)
| eval avg_session_min=round(avg_session_min_raw, 1)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3,
                          mvjoin(mvindex(hosts_flat,0,2), ", ") . " (+" . tostring(unique_targets-3, "commas") . " more)",
                          mvjoin(hosts_flat, ", "))
| eval countries_summary=if(mvcount(countries)>5,
                            mvjoin(mvindex(countries,0,4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)",
                            mvjoin(countries, ", "))
| eval overall_rps=round(total_requests_all/(covered_sec), 2)
| eval campaign_key=if(match(corr_id,"^[0-9a-fA-F:]{16,}$"), "TLS FP " . corr_id, "Host " . mvindex(hosts_flat,0))
| eval severity=case(max_peak_rps>=100000, "CRITICAL",
                     max_peak_rps>=10000,  "HIGH",
                     max_peak_rps>=1000,   "MEDIUM",
                     max_peak_rps>=100,    "LOW",
                     1=1,                  "NORMAL")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps, "commas")
| eval overall_rps_fmt=tostring(overall_rps, "commas")
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| where max_peak_rps>=100 OR total_requests_all>=10000
| sort - max_peak_rps
| table geo.asn campaign_key first_str last_str campaign_span_min active_min session_count avg_session_min max_session_min max_peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_targets primary_targets countries_summary
| rename geo.asn as "ASN"
        campaign_key as "Campaign Key"
        first_str as "First Seen"
        last_str as "Last Seen"
        campaign_span_min as "Span (min)"
        active_min as "Active (min)"
        session_count as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_session_min as "Max Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| spath input=_raw path=identity.tlsFingerprintV3 output=tls_v3
| spath input=_raw path=identity.tlsFingerprintV2 output=tls_v2
| eval tls_fp=coalesce(tls_v3, tls_v2)
| eval corr_id=coalesce(tls_fp, httpMessage.host)
| bin _time span=30s
| stats count as bucket_requests
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
    by geo.asn, corr_id, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, corr_id, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, corr_id, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, corr_id, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, corr_id, httpMessage.host
| stats min(_time) as start
        max(_time) as stop
        sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
    by geo.asn, corr_id, httpMessage.host, session_id
| eval session_sec=stop - start + 30
| eval session_min=round(session_sec/60, 1)
| eval host_list=hosts
| fields geo.asn corr_id start stop session_sec session_min peak_rps total_requests host_list countries
| sort 0 geo.asn, corr_id, start
| streamstats max(stop) as run_max_stop by geo.asn, corr_id
| streamstats current=f window=1 last(run_max_stop) as prev_union_stop by geo.asn, corr_id
| eval add_sec=case(isnull(prev_union_stop), stop - start, start>=prev_union_stop, stop - start, stop>prev_union_stop, stop - prev_union_stop, 1=1, 0)
| streamstats sum(add_sec) as covered_sec by geo.asn, corr_id
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        count as session_count
        avg(session_min) as avg_session_min_raw
        max(session_min) as max_session_min
        min(start) as first_seen
        max(stop) as last_seen
        values(host_list) as all_hosts
        values(countries) as countries
        max(covered_sec) as covered_sec
    by geo.asn, corr_id
| eval campaign_span_min=round((last_seen - first_seen)/60, 1)
| eval active_min=round(covered_sec/60, 1)
| eval avg_session_min=round(avg_session_min_raw, 1)
| eval overall_rps=round(total_requests_all/(covered_sec), 2)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3, mvjoin(mvindex(hosts_flat,0,2), ", ") . " (+" . tostring(unique_targets-3, "commas") . " more)", mvjoin(hosts_flat, ", "))
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries,0,4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)", mvjoin(countries, ", "))
| eval key_type=if(match(corr_id,"^[0-9a-fA-F:]{16,}$"), "TLS FP", "Host")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps, "commas")
| eval overall_rps_fmt=tostring(overall_rps, "commas")
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| where max_peak_rps>=100 OR total_requests_all>=10000
| sort - max_peak_rps
| table geo.asn key_type corr_id first_str last_str campaign_span_min active_min session_count avg_session_min max_session_min max_peak_rps_fmt overall_rps_fmt total_requests_fmt unique_targets primary_targets countries_summary
| rename geo.asn as "ASN"
        key_type as "Key Type"
        corr_id as "Correlation Key"
        first_str as "First Seen"
        last_str as "Last Seen"
        campaign_span_min as "Span (min)"
        active_min as "Active (min)"
        session_count as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_session_min as "Max Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| eval tls_fp=coalesce(identity.tlsFingerprintV3, identity.tlsFingerprintV2, "unknown")
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by geo.asn, tls_fp, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, tls_fp, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, tls_fp, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, tls_fp, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, tls_fp, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        min(_time) as start
        max(_time) as stop
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
    by geo.asn, tls_fp, httpMessage.host, session_id
| eval session_min=round((stop - start + 30)/60, 1)
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        count as session_count
        avg(session_min) as avg_session_min
        max(session_min) as max_session_min
        sum(session_min) as total_active_min
        min(start) as first_seen
        max(stop) as last_seen
        values(hosts) as all_hosts
        values(countries) as countries
        values(tags) as tags
        values(rule_ids) as rule_ids
    by geo.asn, tls_fp
| eval campaign_span_min=round((last_seen - first_seen)/60, 1)
| eval overall_rps=round(total_requests_all/(total_active_min*60), 2)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3, mvjoin(mvindex(hosts_flat,0,2), ", ") . " (+" . tostring(unique_targets-3, "commas") . " more)", mvjoin(hosts_flat, ", "))
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries,0,4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_summary=mvjoin(mvindex(mvsort(mvdedup(tags)),0,4), "; ")
| eval rules_summary=mvjoin(mvindex(mvsort(mvdedup(rule_ids)),0,4), "; ")
| eval severity=case(max_peak_rps>=100000, "CRITICAL", max_peak_rps>=10000, "HIGH", max_peak_rps>=1000, "MEDIUM", max_peak_rps>=100, "LOW", 1=1, "NORMAL")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps, "commas")
| eval overall_rps_fmt=tostring(overall_rps, "commas")
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| where max_peak_rps>=100 OR total_requests_all>=10000
| sort - max_peak_rps
| table geo.asn tls_fp first_str last_str campaign_span_min total_active_min session_count avg_session_min max_session_min max_peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_targets primary_targets countries_summary tags_summary rules_summary
| rename geo.asn as "ASN"
        tls_fp as "TLS FP"
        first_str as "First Seen"
        last_str as "Last Seen"
        campaign_span_min as "Span (min)"
        total_active_min as "Active (min)"
        session_count as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_session_min as "Max Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"



index=akami earliest=-14d@d latest=now
| bin _time span=1s
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| stats count as events_per_second 
    dc(attackData.clientIP) as unique_source_ips 
    dc(user_agent) as unique_user_agents
    values(attackData.clientIP) as source_ips 
    values(user_agent) as user_agents
    values(geo.asn) as source_asn
    values(geo.city) as source_cities
    values(geo.country) as source_countries
    values(httpMessage.method) as http_methods
    values(httpMessage.host) as targeted_hosts
    values(httpMessage.path) as targeted_paths
    values(httpMessage.status) as http_status_codes
    values(attackData.rules{}.id) as attack_rule_ids
    values(attackData.rules{}.message) as attack_rule_messages
    sum(httpMessage.bytes) as total_bytes
    by _time
| where events_per_second > 1000000
| eval events_per_second_formatted=tostring(events_per_second, "commas")
| eval total_gb=round(total_bytes/1024/1024/1024, 2)
| eval attack_severity=case(
    events_per_second >= 7000000, "ðŸ”´ CRITICAL - 7M+ EPS",
    events_per_second >= 5000000, "ðŸŸ  HIGH - 5M+ EPS",
    events_per_second >= 1000000, "ðŸŸ¡ ELEVATED - 1M+ EPS")
| eval time_of_attack=strftime(_time, "%Y-%m-%d %H:%M:%S %Z")
| eval source_ips_top10=mvindex(source_ips, 0, 9)
| eval source_ips_display=if(mvcount(source_ips) > 10, mvjoin(source_ips_top10, ", ") + " ... [+" + tostring(mvcount(source_ips) - 10, "commas") + " more IPs]", mvjoin(source_ips, ", "))
| eval user_agents_top5=mvindex(user_agents, 0, 4)
| eval user_agents_display=if(mvcount(user_agents) > 5, mvjoin(user_agents_top5, " | ") + " ... [+" + tostring(mvcount(user_agents) - 5, "commas") + " more]", mvjoin(user_agents, " | "))
| eval attack_pattern=case(
    unique_source_ips < 100 AND events_per_second > 5000000, "Concentrated Attack (Few IPs, High Volume)",
    unique_source_ips > 10000, "Distributed Botnet (Many IPs)",
    unique_user_agents < 5, "Scripted/Automated Attack",
    1=1, "Mixed Pattern")
| table time_of_attack, events_per_second_formatted, attack_severity, attack_pattern, unique_source_ips, source_ips_display, unique_user_agents, user_agents_display, source_countries, source_cities, source_asn, http_methods, targeted_hosts, targeted_paths, http_status_codes, attack_rule_ids, attack_rule_messages, total_gb
| sort -events_per_second_formatted
| rename time_of_attack as "Date/Time", events_per_second_formatted as "Events/Sec", attack_severity as "Severity", attack_pattern as "Attack Pattern", unique_source_ips as "Unique IPs", source_ips_display as "Top Source IPs (Sample)", unique_user_agents as "Unique UAs", user_agents_display as "Top User Agents (Sample)", source_countries as "Countries", source_cities as "Cities", source_asn as "ASN", http_methods as "HTTP Methods", targeted_hosts as "Targeted Hosts", targeted_paths as "Targeted Paths", http_status_codes as "Status Codes", attack_rule_ids as "WAF Rule IDs", attack_rule_messages as "WAF Rule Messages", total_gb as "Total GB"




index=akami earliest=-14d@d latest=now
| bin _time span=1s
| stats count as events_per_second 
    dc(attackData.clientIP) as unique_source_ips 
    values(geo.country) as source_countries
    values(httpMessage.method) as http_methods
    values(httpMessage.host) as targeted_hosts
    max(attackData.rules{}.message) as primary_attack_type
    by _time
| where events_per_second > 1000
| eval events_per_second_formatted=tostring(events_per_second, "commas")
| eval attack_severity=case(
    events_per_second >= 1000000, "CRITICAL",
    events_per_second >= 100000, "HIGH",
    events_per_second >= 10000, "MEDIUM",
    events_per_second >= 1000, "LOW",
    1=1, "INFO")
| eval time_of_attack=strftime(_time, "%Y-%m-%d %H:%M:%S UTC")
| eval countries_display=mvindex(source_countries, 0, 4)
| eval countries_summary=if(mvcount(source_countries) > 5, mvjoin(countries_display, ", ") + " (+" + tostring(mvcount(source_countries) - 5, "commas") + " more)", mvjoin(source_countries, ", "))
| eval target_summary=mvindex(targeted_hosts, 0, 2)
| table time_of_attack, events_per_second_formatted, attack_severity, unique_source_ips, countries_summary, primary_attack_type, target_summary
| sort -events_per_second_formatted
| head 50
| rename time_of_attack as "Time (UTC)", events_per_second_formatted as "Events/Sec", attack_severity as "Severity", unique_source_ips as "Source IPs", countries_summary as "Origin Countries", primary_attack_type as "Attack Type", target_summary as "Targets"




index=akami earliest=-14d@d latest=now
| bin _time span=5m
| stats count as events
    dc(attackData.clientIP) as unique_ips
    values(geo.country) as countries
    values(httpMessage.host) as targets
    values(attackData.rules{}.message) as attack_types
    by _time
| streamstats time_window=30m sum(events) as rolling_30min_events current=f
| where events > 100000 OR unique_ips > 10000
| streamstats count as window_count reset_after="(events < 100000)"
| eventstats min(_time) as attack_start, max(_time) as attack_end, sum(events) as total_attack_events, dc(unique_ips) as total_unique_ips, values(countries) as all_countries, values(targets) as all_targets, values(attack_types) as all_attack_types by window_count
| where _time=attack_start
| eval attack_duration_min=round((attack_end - attack_start)/60, 0)
| eval attack_start_time=strftime(attack_start, "%Y-%m-%d %H:%M UTC")
| eval attack_end_time=strftime(attack_end, "%Y-%m-%d %H:%M UTC")
| eval total_events_fmt=tostring(total_attack_events, "commas")
| eval avg_eps=round(total_attack_events / (attack_end - attack_start), 0)
| eval avg_eps_fmt=tostring(avg_eps, "commas")
| eval severity=case(avg_eps >= 1000000, "CRITICAL", avg_eps >= 100000, "HIGH", avg_eps >= 10000, "MEDIUM", 1=1, "LOW")
| eval countries_display=if(mvcount(all_countries) > 10, mvjoin(mvindex(all_countries, 0, 9), ", ") + " (+" + tostring(mvcount(all_countries)-10) + " more)", mvjoin(all_countries, ", "))
| eval targets_display=if(mvcount(all_targets) > 3, mvjoin(mvindex(all_targets, 0, 2), ", ") + " (+" + tostring(mvcount(all_targets)-3) + " more)", mvjoin(all_targets, ", "))
| eval attack_summary=mvjoin(mvindex(all_attack_types, 0, 3), " | ")
| table attack_start_time, attack_end_time, attack_duration_min, total_events_fmt, avg_eps_fmt, severity, total_unique_ips, countries_display, targets_display, attack_summary
| sort - attack_start_time
| rename attack_start_time as "Attack Start", attack_end_time as "Attack End", attack_duration_min as "Duration (min)", total_events_fmt as "Total Events", avg_eps_fmt as "Avg EPS", severity as "Severity", total_unique_ips as "Unique IPs", countries_display as "Origin Countries", targets_display as "Targeted Hosts", attack_summary as "Attack Types"



index=akami earliest=-14d@d latest=now
| bucket _time span=10m
| stats count as events
    dc(attackData.clientIP) as unique_ips
    values(geo.country) as countries
    values(httpMessage.host) as targets
    values(httpMessage.method) as methods
    values(attackData.rules{}.message) as attack_types
    by _time
| sort 0 _time
| streamstats current=f window=1 last(_time) as prev_time
| eval time_gap=(_time - prev_time)
| eval is_new_attack=if(time_gap > 1800 OR isnull(time_gap), 1, 0)
| streamstats sum(is_new_attack) as attack_id
| eventstats 
    min(_time) as attack_start
    max(_time) as attack_end
    sum(events) as total_events
    sum(unique_ips) as total_ips
    values(countries) as all_countries
    values(targets) as all_targets
    values(methods) as all_methods
    values(attack_types) as all_attack_types
    by attack_id
| where _time=attack_start
| eval duration_min=round((attack_end - attack_start)/60, 0)
| eval start_time=strftime(attack_start, "%Y-%m-%d %H:%M UTC")
| eval end_time=strftime(attack_end, "%Y-%m-%d %H:%M UTC")
| eval events_formatted=tostring(total_events, "commas")
| eval ips_formatted=tostring(total_ips, "commas")
| eval avg_eps=round(total_events / ((attack_end - attack_start) + 1), 0)
| eval avg_eps_formatted=tostring(avg_eps, "commas")
| eval severity=case(
    avg_eps >= 1000000, "CRITICAL",
    avg_eps >= 100000, "HIGH", 
    avg_eps >= 10000, "MEDIUM",
    1=1, "LOW")
| eval country_list=if(mvcount(all_countries) > 8, mvjoin(mvindex(all_countries, 0, 7), ", ") + " (+" + tostring(mvcount(all_countries)-8) + " more)", mvjoin(all_countries, ", "))
| eval target_list=if(mvcount(all_targets) > 2, mvjoin(mvindex(all_targets, 0, 1), ", ") + " (+" + tostring(mvcount(all_targets)-2) + " more)", mvjoin(all_targets, ", "))
| eval attack_type_list=mvjoin(mvindex(all_attack_types, 0, 2), " | ")
| table start_time, end_time, duration_min, events_formatted, avg_eps_formatted, severity, ips_formatted, country_list, target_list, attack_type_list
| sort - start_time
| rename 
    start_time as "Attack Start" 
    end_time as "Attack End" 
    duration_min as "Duration (min)" 
    events_formatted as "Total Events" 
    avg_eps_formatted as "Avg EPS" 
    severity as "Severity" 
    ips_formatted as "Unique IPs" 
    country_list as "Countries" 
    target_list as "Targets" 
    attack_type_list as "Attack Types"



index=akami earliest=-14d@d latest=now
| bucket _time span=5m
| stats count as events
    dc(attackData.clientIP) as unique_ips
    values(geo.country) as countries
    values(httpMessage.host) as targets
    values(attackData.rules{}.message) as attack_types
    by _time
| eval eps=round(events/300, 0)
| eval eps_formatted=tostring(eps, "commas")
| eval events_formatted=tostring(events, "commas")
| eval ips_formatted=tostring(unique_ips, "commas")
| eval severity=case(
    eps >= 100000, "CRITICAL",
    eps >= 10000, "HIGH",
    eps >= 1000, "MEDIUM",
    eps >= 100, "LOW",
    1=1, "NORMAL")
| eval time_utc=strftime(_time, "%Y-%m-%d %H:%M UTC")
| eval countries_display=if(mvcount(countries) > 8, mvjoin(mvindex(countries, 0, 7), ", ") + " (+" + tostring(mvcount(countries)-8) + " more)", mvjoin(countries, ", "))
| eval targets_display=if(mvcount(targets) > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(mvcount(targets)-3) + " more)", mvjoin(targets, ", "))
| eval attack_summary=mvjoin(mvindex(attack_types, 0, 2), " | ")
| where eps >= 1000
| table time_utc, events_formatted, eps_formatted, severity, ips_formatted, countries_display, targets_display, attack_summary
| sort - eps
| head 50
| rename time_utc as "Time (UTC)", events_formatted as "Events (5min)", eps_formatted as "Avg EPS", severity as "Severity", ips_formatted as "Unique IPs", countries_display as "Countries", targets_display as "Targets", attack_summary as "Attack Types"




index=akami earliest=-14d@d latest=now
| stats count as total_events
    dc(attackData.clientIP) as unique_ips
    dc(geo.country) as countries
    values(geo.country) as country_list
    values(httpMessage.host) as targeted_hosts
    min(_time) as first_seen
    max(_time) as last_seen
    by attackData.rules{}.message
| eval duration_hours=round((last_seen - first_seen)/3600, 1)
| eval events_fmt=tostring(total_events, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval first_seen_time=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_time=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval severity=case(
    total_events >= 1000000, "CRITICAL",
    total_events >= 100000, "HIGH",
    total_events >= 10000, "MEDIUM",
    1=1, "LOW")
| eval targets=if(mvcount(targeted_hosts) > 3, mvjoin(mvindex(targeted_hosts, 0, 2), ", ") + " (+" + tostring(mvcount(targeted_hosts)-3) + " more)", mvjoin(targeted_hosts, ", "))
| table attackData.rules{}.message, events_fmt, severity, ips_fmt, countries, first_seen_time, last_seen_time, duration_hours, targets
| sort - total_events
| rename attackData.rules{}.message as "Attack Type", events_fmt as "Total Events", severity as "Severity", ips_fmt as "Unique IPs", countries as "Countries", first_seen_time as "First Seen", last_seen_time as "Last Seen", duration_hours as "Duration (hrs)", targets as "Targets"

index=akami earliest=-24h@h latest=now
| rex field=attackData.rules{}.message "(?<attack_category>^[^(|]+)"
| eval attack_category=trim(attack_category)
| stats count as total_events
    dc(attackData.clientIP) as unique_ips
    dc(httpMessage.host) as unique_targets
    values(httpMessage.host) as targets
    dc(geo.country) as country_count
    min(_time) as first_seen
    max(_time) as last_seen
    by attack_category
| where isnotnull(attack_category)
| eval duration_hours=round((last_seen - first_seen)/3600, 1)
| eval events_fmt=tostring(total_events, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval first_time=strftime(first_seen, "%m-%d %H:%M")
| eval last_time=strftime(last_seen, "%m-%d %H:%M")
| eval severity=case(
    total_events >= 100000, "CRITICAL",
    total_events >= 50000, "HIGH",
    total_events >= 10000, "MEDIUM",
    1=1, "LOW")
| eval target_display=if(unique_targets > 3, mvindex(targets, 0, 2) + " (+" + tostring(unique_targets-3) + " more)", mvjoin(targets, ", "))
| table attack_category, events_fmt, severity, ips_fmt, country_count, first_time, last_time, duration_hours, target_display
| sort - total_events
| head 20
| rename attack_category as "Attack Type", events_fmt as "Events", severity as "Severity", ips_fmt as "Source IPs", country_count as "Countries", first_time as "First Seen", last_time as "Last Seen", duration_hours as "Duration (hrs)", target_display as "Targets"


index=akami earliest=-14d@d latest=now
| stats 
    count as total_events
    dc(attackData.rules{}.message) as attack_techniques
    values(httpMessage.host) as targets
    dc(httpMessage.host) as unique_targets
    values(geo.country) as country
    values(geo.asn) as asn
    min(_time) as first_seen
    max(_time) as last_seen
    by attackData.clientIP
| where total_events > 100
| eval duration_sec=(last_seen - first_seen)
| eval rps=round(total_events / duration_sec, 2)
| eval events_fmt=tostring(total_events, "commas")
| eval rps_fmt=tostring(rps, "commas")
| eval severity=case(
    rps >= 1000, "CRITICAL",
    rps >= 100, "HIGH",
    rps >= 10, "MEDIUM",
    1=1, "LOW")
| eval first_time=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_time=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_display=tostring(round(duration_sec/60, 0)) + "m"
| eval target_list=if(unique_targets > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(unique_targets - 3) + " more)", mvjoin(targets, ", "))
| sort - rps
| head 50
| table attackData.clientIP, rps_fmt, events_fmt, severity, attack_techniques, country, asn, first_time, last_time, duration_display, target_list
| rename 
    attackData.clientIP as "Source IP"
    rps_fmt as "RPS"
    events_fmt as "Total Requests"
    severity as "Severity"
    attack_techniques as "Techniques"
    country as "Country"
    asn as "ASN"
    first_time as "First Seen"
    last_time as "Last Seen"
    duration_display as "Duration"
    target_list as "Targets"


index=akami earliest=-24h@h latest=now
| rex field=attackData.rules{}.message "(?<attack_category>^[^(|]+)"
| eval attack_category=trim(attack_category)
| stats count as total_events, dc(attackData.clientIP) as unique_ips, dc(httpMessage.host) as unique_targets, values(httpMessage.host) as targets, dc(geo.country) as country_count, min(_time) as first_seen, max(_time) as last_seen by attack_category
| where isnotnull(attack_category) AND total_events > 0
| eval duration_hours=round((last_seen - first_seen) / 3600, 1)
| eval events_fmt=tostring(total_events, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval first_time=strftime(first_seen, "%m-%d %H:%M")
| eval last_time=strftime(last_seen, "%m-%d %H:%M")
| eval severity=case(total_events >= 100000, "CRITICAL", total_events >= 50000, "HIGH", total_events >= 10000, "MEDIUM", total_events >= 1000, "LOW", 1=1, "INFO")
| eval target_display=if(unique_targets > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(unique_targets - 3) + " more)", mvjoin(targets, ", "))
| sort limit=20 - total_events
| table attack_category, events_fmt, severity, ips_fmt, country_count, first_time, last_time, duration_hours, target_display
| rename attack_category as "Attack Type", events_fmt as "Events", severity as "Severity", ips_fmt as "Source IPs", country_count as "Countries", first_time as "First Seen", last_time as "Last Seen", duration_hours as "Duration (hrs)", target_display as "Targets"


index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| stats 
    count as total_requests
    dc(attackData.clientIP) as unique_ips
    dc(attack_type) as attack_types_count
    values(attack_type) as attack_types
    dc(user_agent) as unique_user_agents
    values(user_agent) as user_agents
    values(httpMessage.host) as targets
    dc(httpMessage.host) as target_count
    values(geo.country) as countries
    dc(geo.country) as country_count
    min(_time) as first_seen
    max(_time) as last_seen
    by geo.asn
| where isnotnull(geo.asn) AND total_requests > 1000
| eval duration_sec=(last_seen - first_seen) + 1
| eval rps=round(total_requests / duration_sec, 0)
| eval requests_fmt=tostring(total_requests, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval rps_fmt=tostring(rps, "commas")
| eval severity=case(
    rps >= 1000000, "CRITICAL (1M+ RPS)",
    rps >= 100000, "HIGH (100K-1M RPS)",
    rps >= 10000, "MEDIUM (10K-100K RPS)",
    rps >= 1000, "LOW (1K-10K RPS)",
    1=1, "INFO")
| eval first_time=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_time=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min=tostring(round(duration_sec/60, 0)) + "m"
| eval attack_summary=if(attack_types_count > 5, mvjoin(mvindex(attack_types, 0, 4), " | ") + " (+" + tostring(attack_types_count - 5) + " more)", mvjoin(attack_types, " | "))
| eval ua_summary=if(unique_user_agents > 3, mvjoin(mvindex(user_agents, 0, 2), " | ") + " (+" + tostring(unique_user_agents - 3) + " more)", if(unique_user_agents > 0, mvjoin(user_agents, " | "), "N/A"))
| eval target_summary=if(target_count > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(target_count - 3) + " more)", mvjoin(targets, ", "))
| eval country_summary=if(country_count > 5, mvjoin(mvindex(countries, 0, 4), ", ") + " (+" + tostring(country_count - 5) + " more)", mvjoin(countries, ", "))
| sort - rps
| head 30
| table geo.asn, rps_fmt, severity, requests_fmt, ips_fmt, attack_types_count, attack_summary, ua_summary, country_summary, first_time, last_time, duration_min, target_summary
| rename 
    geo.asn as "ASN"
    rps_fmt as "RPS"
    severity as "Severity"
    requests_fmt as "Total Requests"
    ips_fmt as "Unique IPs"
    attack_types_count as "Attack Types"
    attack_summary as "Attack Methods"
    ua_summary as "User Agents"
    country_summary as "Countries"
    first_time as "First Seen"
    last_time as "Last Seen"
    duration_min as "Duration"
    target_summary as "Targets"



index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| stats 
    count as total_requests
    dc(attackData.clientIP) as unique_ips
    dc(attack_type) as attack_types_count
    values(attack_type) as attack_types
    dc(user_agent) as unique_user_agents
    values(user_agent) as user_agents
    values(httpMessage.host) as targets
    dc(httpMessage.host) as target_count
    values(geo.country) as countries
    dc(geo.country) as country_count
    min(_time) as first_seen
    max(_time) as last_seen
    by geo.asn
| where isnotnull(geo.asn) AND total_requests > 1000
| eval duration_sec=(last_seen - first_seen) + 1
| eval rps=round(total_requests / duration_sec, 0)
| eval requests_fmt=tostring(total_requests, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval rps_fmt=tostring(rps, "commas")
| eval severity=case(
    rps >= 1000000, "CRITICAL (1M+ RPS)",
    rps >= 100000, "HIGH (100K-1M RPS)",
    rps >= 10000, "MEDIUM (10K-100K RPS)",
    rps >= 1000, "LOW (1K-10K RPS)",
    1=1, "INFO")
| eval first_time=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_time=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min=tostring(round(duration_sec/60, 0)) + "m"
| eval attack_summary=if(attack_types_count > 5, mvjoin(mvindex(attack_types, 0, 4), " | ") + " (+" + tostring(attack_types_count - 5) + " more)", mvjoin(attack_types, " | "))
| eval ua_summary=if(unique_user_agents > 3, mvjoin(mvindex(user_agents, 0, 2), " | ") + " (+" + tostring(unique_user_agents - 3) + " more)", if(unique_user_agents > 0, mvjoin(user_agents, " | "), "N/A"))
| eval target_summary=if(target_count > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(target_count - 3) + " more)", mvjoin(targets, ", "))
| eval country_summary=if(country_count > 5, mvjoin(mvindex(countries, 0, 4), ", ") + " (+" + tostring(country_count - 5) + " more)", mvjoin(countries, ", "))
| sort - rps
| head 30
| table geo.asn, rps_fmt, severity, requests_fmt, ips_fmt, attack_types_count, attack_summary, ua_summary, country_summary, first_time, last_time, duration_min, target_summary
| rename 
    geo.asn as "ASN"
    rps_fmt as "RPS"
    severity as "Severity"
    requests_fmt as "Total Requests"
    ips_fmt as "Unique IPs"
    attack_types_count as "Attack Types"
    attack_summary as "Attack Methods"
    ua_summary as "User Agents"
    country_summary as "Countries"
    first_time as "First Seen"
    last_time as "Last Seen"
    duration_min as "Duration"
    target_summary as "Targets"


index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| stats 
    count as total_requests
    dc(attackData.clientIP) as unique_ips
    dc(attack_type) as attack_types_count
    values(attack_type) as attack_types
    values(httpMessage.host) as targets
    dc(httpMessage.host) as target_count
    values(geo.country) as countries
    min(_time) as first_seen
    max(_time) as last_seen
    by geo.asn
| eval duration_sec=(last_seen - first_seen) + 1
| eval rps=round(total_requests / duration_sec, 0)
| eval requests_fmt=tostring(total_requests, "commas")
| eval ips_fmt=tostring(unique_ips, "commas")
| eval rps_fmt=tostring(rps, "commas")
| eval severity=case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "INFO")
| eval first_time=strftime(first_seen, "%Y-%m-%d %H:%M")
| eval last_time=strftime(last_seen, "%Y-%m-%d %H:%M")
| eval attack_summary=mvjoin(mvindex(attack_types, 0, 3), " | ")
| eval target_summary=mvjoin(mvindex(targets, 0, 2), ", ")
| eval country_summary=mvjoin(countries, ", ")
| sort - rps
| head 50
| table geo.asn, rps_fmt, severity, requests_fmt, ips_fmt, attack_types_count, attack_summary, country_summary, first_time, last_time, target_summary
| rename 
    geo.asn as "ASN"
    rps_fmt as "RPS"
    severity as "Severity"
    requests_fmt as "Requests"
    ips_fmt as "IPs"
    attack_types_count as "Attack Types"
    attack_summary as "Methods"
    country_summary as "Countries"
    first_time as "First"
    last_time as "Last"
    target_summary as "Targets"



index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval user_agent=coalesce(user_agent, "N/A"), attack_type=coalesce(attack_type, "Unknown")
| stats 
    count AS total_requests,
    dc(attackData.clientIP) AS unique_ips,
    dc(httpMessage.host) AS unique_targets,
    values(httpMessage.host) AS targets,
    dc(geo.country) AS country_count,
    values(geo.country) AS countries,
    values(geo.asn) AS asn,
    min(_time) AS first_seen,
    max(_time) AS last_seen,
    dc(user_agent) AS unique_uas,
    values(user_agent) AS user_agents,
    values(attack_type) AS raw_attack_types
  BY geo.asn, user_agent
| eval attack_types=mvsort(mvdedup(raw_attack_types))
| eval attack_summary=mvjoin(attack_types, "\n")
| eval duration_sec=(last_seen - first_seen) + 1
| eval rps=round(total_requests / duration_sec, 2)
| eval severity=case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "NORMAL"
)
| eval first_seen_str=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min=round(duration_sec / 60, 1)
| eval requests_fmt=tostring(total_requests, "commas")
| eval rps_fmt=tostring(rps, "commas")
| eval ua_summary=if(unique_uas > 2, mvjoin(mvindex(user_agents, 0, 2), " | ") + " (+" + tostring(unique_uas - 2) + " more)", mvjoin(user_agents, " | "))
| eval target_summary=if(unique_targets > 3, mvjoin(mvindex(targets, 0, 2), ", ") + " (+" + tostring(unique_targets - 2) + " more)", mvjoin(targets, ", "))
| eval country_summary=if(country_count > 4, mvjoin(mvindex(countries, 0, 3), ", ") + " (+" + tostring(country_count - 3) + " more)", mvjoin(countries, ", "))
| sort - rps
| head 30
| table asn, rps_fmt, severity, requests_fmt, unique_ips, ua_summary, country_summary, first_seen_str, last_seen_str, duration_min, target_summary, attack_summary
| rename 
    asn as "ASN",
    rps_fmt as "RPS",
    severity as "Severity",
    requests_fmt as "Total Requests",
    unique_ips as "Unique IPs",
    ua_summary as "User Agents",
    country_summary as "Countries",
    first_seen_str as "First Seen",
    last_seen_str as "Last Seen",
    duration_min as "Duration (min)",
    target_summary as "Targets",
    attack_summary as "Attack Types"



index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval user_agent=coalesce(user_agent, "N/A"), attack_type=trim(attack_type)
| stats 
    count AS total_requests,
    dc(attackData.clientIP) AS unique_ips,
    dc(httpMessage.host) AS unique_targets,
    values(httpMessage.host) AS targets,
    dc(geo.country) AS country_count,
    values(geo.country) AS countries,
    values(geo.asn) AS asn,
    min(_time) AS first_seen,
    max(_time) AS last_seen,
    dc(user_agent) AS unique_uas,
    values(user_agent) AS user_agents,
    values(attack_type) AS attack_type_list
  BY geo.asn, user_agent
| eval duration_sec = (last_seen - first_seen) + 1
| eval rps = round(total_requests / duration_sec, 2)
| eval severity = case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "NORMAL"
)
| eval first_seen_str = strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str = strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min = round(duration_sec / 60, 1)
| eval requests_fmt = tostring(total_requests, "commas")
| eval rps_fmt = tostring(rps, "commas")
| eval ua_summary = if(unique_uas > 2, mvjoin(mvindex(user_agents, 0, 2), " | ") . " (+" . tostring(unique_uas - 2) . " more)", mvjoin(user_agents, " | "))
| eval target_summary = if(unique_targets > 3, mvjoin(mvindex(targets, 0, 2), ", ") . " (+" . tostring(unique_targets - 2) . " more)", mvjoin(targets, ", "))
| eval country_summary = if(country_count > 4, mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(country_count - 3) . " more)", mvjoin(countries, ", "))
| eval attack_types = mvsort(mvdedup(attack_type_list))
| eval attack_summary = if(
    mvcount(attack_types) > 5,
    mvjoin(mvindex(attack_types, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_types) - 5) . " more)",
    mvjoin(attack_types, "; ")
)
| sort - rps
| head 30
| table asn, rps_fmt, severity, requests_fmt, unique_ips, ua_summary, country_summary, first_seen_str, last_seen_str, duration_min, target_summary, attack_summary
| rename 
    asn as "ASN",
    rps_fmt as "RPS",
    severity as "Severity",
    requests_fmt as "Total Requests",
    unique_ips as "Unique IPs",
    ua_summary as "User Agents",
    country_summary as "Countries",
    first_seen_str as "First Seen",
    last_seen_str as "Last Seen",
    duration_min as "Duration (min)",
    target_summary as "Targets",
    attack_summary as "Attack Types"


index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| eval norm_ua=lower(replace(user_agent, "\d+\.\d+(\.\d+)?", ""))  // Strip version numbers
| eval norm_ua=replace(norm_ua, "[^a-z0-9]+", "_")
| eval user_agent_group=substr(norm_ua, 0, 60)  // Truncate noise
| eval user_agent_group=coalesce(user_agent_group, "unknown_ua")
| eval attack_type_clean=coalesce(attack_type, "Unknown")
| stats 
    count AS total_requests,
    dc(attackData.clientIP) AS unique_ips,
    dc(httpMessage.host) AS unique_targets,
    values(httpMessage.host) AS targets,
    dc(geo.country) AS country_count,
    values(geo.country) AS countries,
    values(geo.asn) AS asn,
    min(_time) AS first_seen,
    max(_time) AS last_seen,
    dc(user_agent_group) AS ua_groups,
    values(user_agent) AS raw_uas,
    values(attack_type_clean) AS raw_attack_types
  BY geo.asn, user_agent_group, httpMessage.host
| eval duration_sec = (last_seen - first_seen) + 1
| eval rps = round(total_requests / duration_sec, 2)
| eval severity = case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "NORMAL"
)
| eval first_seen_str = strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str = strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min = round(duration_sec / 60, 1)
| eval requests_fmt = tostring(total_requests, "commas")
| eval rps_fmt = tostring(rps, "commas")
| eval ua_summary = mvjoin(mvsort(mvdedup(raw_uas)), " | ")
| eval target_summary = if(unique_targets > 3, mvjoin(mvindex(targets, 0, 2), ", ") . " (+" . tostring(unique_targets - 2) . " more)", mvjoin(targets, ", "))
| eval country_summary = if(country_count > 4, mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(country_count - 3) . " more)", mvjoin(countries, ", "))
| eval attack_types = mvsort(mvdedup(raw_attack_types))
| eval attack_summary = if(
    mvcount(attack_types) > 5,
    mvjoin(mvindex(attack_types, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_types) - 5) . " more)",
    mvjoin(attack_types, "; ")
)
| sort - rps
| head 30
| table asn, rps_fmt, severity, requests_fmt, unique_ips, ua_summary, country_summary, first_seen_str, last_seen_str, duration_min, target_summary, attack_summary
| rename 
    asn as "ASN",
    rps_fmt as "RPS",
    severity as "Severity",
    requests_fmt as "Total Requests",
    unique_ips as "Unique IPs",
    ua_summary as "User Agents",
    country_summary as "Countries",
    first_seen_str as "First Seen",
    last_seen_str as "Last Seen",
    duration_min as "Duration (min)",
    target_summary as "Targets",
    attack_summary as "Attack Types"



index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type), user_agent=coalesce(user_agent, "N/A")
| stats 
    count AS total_requests,
    dc(attackData.clientIP) AS unique_ips,
    dc(httpMessage.host) AS unique_targets,
    dc(geo.country) AS country_count,
    values(geo.country) AS countries,
    values(geo.asn) AS asn,
    min(_time) AS first_seen,
    max(_time) AS last_seen,
    dc(user_agent) AS unique_user_agents,
    values(attack_type) AS raw_attack_types
  BY geo.asn, user_agent
| eval duration_sec = (last_seen - first_seen) + 1
| eval rps = round(total_requests / duration_sec, 2)
| eval severity = case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "NORMAL"
)
| eval first_seen_str = strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str = strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min = round(duration_sec / 60, 1)
| eval requests_fmt = tostring(total_requests, "commas")
| eval rps_fmt = tostring(rps, "commas")
| eval country_summary = if(country_count > 4, mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(country_count - 3) . " more)", mvjoin(countries, ", "))
| eval attack_types = mvsort(mvdedup(raw_attack_types))
| eval attack_summary = if(
    mvcount(attack_types) > 5,
    mvjoin(mvindex(attack_types, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_types) - 5) . " more)",
    mvjoin(attack_types, "; ")
)
| sort - rps
| head 30
| table asn, rps_fmt, severity, requests_fmt, unique_ips, unique_user_agents, country_summary, first_seen_str, last_seen_str, duration_min, unique_targets, attack_summary
| rename 
    asn as "ASN",
    rps_fmt as "RPS",
    severity as "Severity",
    requests_fmt as "Total Requests",
    unique_ips as "Unique IPs",
    unique_user_agents as "Unique UAs",
    country_summary as "Countries",
    first_seen_str as "First Seen",
    last_seen_str as "Last Seen",
    duration_min as "Duration (min)",
    unique_targets as "Unique Targets",
    attack_summary as "Attack Types"


index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type), user_agent=coalesce(user_agent, "N/A")
| eval ts=_time
| stats 
    count AS event_count,
    dc(attackData.clientIP) AS unique_ips,
    dc(httpMessage.host) AS unique_targets,
    dc(user_agent) AS unique_user_agents,
    dc(geo.country) AS country_count,
    values(httpMessage.host) AS targets,
    values(geo.country) AS countries,
    values(attack_type) AS attack_types,
    values(attackData.clientIP) AS ips,
    sum(httpMessage.bytes) AS bytes_total,
    min(ts) AS first_seen,
    max(ts) AS last_seen
  BY geo.asn, user_agent, _time
| sort 0 geo.asn, user_agent, _time
| streamstats current=f window=1 last(_time) AS prev_time BY geo.asn, user_agent
| eval time_gap = _time - prev_time
| eval new_attack = if(isnull(prev_time) OR time_gap > 300, 1, 0)
| streamstats sum(new_attack) AS attack_id BY geo.asn, user_agent
| eventstats 
    min(first_seen) AS attack_start,
    max(last_seen) AS attack_end,
    sum(event_count) AS total_requests,
    dc(unique_ips) AS total_unique_ips,
    dc(unique_targets) AS total_unique_targets,
    dc(unique_user_agents) AS total_unique_uas,
    values(countries) AS all_countries,
    values(attack_types) AS all_attack_types
  BY geo.asn, user_agent, attack_id
| where _time = attack_start
| eval duration_sec = attack_end - attack_start + 1
| eval rps = round(total_requests / duration_sec, 2)
| eval severity = case(
    rps >= 1000000, "CRITICAL",
    rps >= 100000, "HIGH",
    rps >= 10000, "MEDIUM",
    rps >= 1000, "LOW",
    1=1, "NORMAL"
)
| eval first_seen_str = strftime(attack_start, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str = strftime(attack_end, "%Y-%m-%d %H:%M UTC")
| eval duration_min = round(duration_sec / 60, 1)
| eval requests_fmt = tostring(total_requests, "commas")
| eval rps_fmt = tostring(rps, "commas")
| eval country_summary = if(mvcount(all_countries) > 4, mvjoin(mvindex(all_countries, 0, 3), ", ") . " (+" . tostring(mvcount(all_countries) - 3) . " more)", mvjoin(all_countries, ", "))
| eval attack_type_summary = mvsort(mvdedup(all_attack_types))
| eval attack_summary = if(
    mvcount(attack_type_summary) > 5,
    mvjoin(mvindex(attack_type_summary, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_type_summary) - 5) . " more)",
    mvjoin(attack_type_summary, "; ")
)
| table geo.asn, user_agent, rps_fmt, severity, requests_fmt, total_unique_ips, total_unique_uas, country_summary, first_seen_str, last_seen_str, duration_min, total_unique_targets, attack_summary
| rename 
    geo.asn AS "ASN",
    user_agent AS "User Agent",
    rps_fmt AS "RPS",
    severity AS "Severity",
    requests_fmt AS "Total Requests",
    total_unique_ips AS "Unique IPs",
    total_unique_uas AS "Unique UAs",
    country_summary AS "Countries",
    first_seen_str AS "First Seen",
    last_seen_str AS "Last Seen",
    duration_min AS "Duration (min)",
    total_unique_targets AS "Unique Targets",
    attack_summary AS "Attack Types"


index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval user_agent=coalesce(user_agent,"N/A"), attack_type=trim(attack_type)
| bin _time span=1m
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        dc(httpMessage.host) as bucket_unique_targets
        dc(user_agent) as bucket_unique_uas
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
        min(_time) as bucket_start
        max(_time) as bucket_end
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/60,2)
| where bucket_rps > 0
| sort 0 geo.asn _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval gap=_time - prev_time
| eval new_attack=if(isnull(prev_time) OR gap > 600,1,0)
| streamstats sum(new_attack) as attack_id by geo.asn
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        max(bucket_unique_uas) as unique_uas
        values(bucket_countries) as countries
        values(bucket_attack_types) as all_attack_types
        min(bucket_start) as first_seen
        max(bucket_end) as last_seen
    by geo.asn, attack_id
| eval duration_sec=last_seen - first_seen + 60
| eval rps=round(total_requests/duration_sec,2)
| eval severity=case(
        rps >= 1000000,"CRITICAL",
        rps >= 100000,"HIGH",
        rps >= 10000,"MEDIUM",
        rps >= 1000,"LOW",
        1=1,"NORMAL"
    )
| eval first_seen_str=strftime(first_seen,"%Y-%m-%d %H:%M UTC")
| eval last_seen_str=strftime(last_seen,"%Y-%m-%d %H:%M UTC")
| eval duration_min=round(duration_sec/60,1)
| eval requests_fmt=tostring(total_requests,"commas")
| eval rps_fmt=tostring(rps,"commas")
| eval country_summary=if(mvcount(countries)>4,mvjoin(mvindex(countries,0,3),", ") . " (+" . tostring(mvcount(countries)-3) . " more)",mvjoin(countries,", "))
| eval attack_type_list=mvsort(mvdedup(all_attack_types))
| eval attack_summary=if(mvcount(attack_type_list)>5,mvjoin(mvindex(attack_type_list,0,4),"; ") . "; (+" . tostring(mvcount(attack_type_list)-5) . " more)",mvjoin(attack_type_list,"; "))
| where rps >= 100
| sort - rps
| table geo.asn, rps_fmt, severity, requests_fmt, unique_ips, unique_uas, country_summary, first_seen_str, last_seen_str, duration_min, unique_targets, attack_summary
| rename geo.asn as "ASN",
        rps_fmt as "RPS",
        severity as "Severity",
        requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        unique_uas as "Unique UAs",
        country_summary as "Countries",
        first_seen_str as "First Seen",
        last_seen_str as "Last Seen",
        duration_min as "Duration (min)",
        unique_targets as "Unique Targets",
        attack_summary as "Attack Types"




index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval user_agent=coalesce(user_agent,"N/A"), attack_type=trim(attack_type)
| bin _time span=1m
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        dc(httpMessage.host) as bucket_unique_targets
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/60,2)
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        values(bucket_countries) as countries
        values(bucket_attack_types) as all_attack_types
        min(_time) as first_seen
        max(_time) as last_seen
    by geo.asn
| eval duration_sec=last_seen - first_seen + 60
| eval severity=case(
        peak_rps >= 100000, "CRITICAL",
        peak_rps >= 10000, "HIGH",
        peak_rps >= 1000, "MEDIUM",
        peak_rps >= 100, "LOW",
        1=1, "NORMAL"
    )
| eval first_seen_str=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min=round(duration_sec/60,1)
| eval requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval country_summary=if(
        mvcount(countries)>4,
        mvjoin(mvindex(countries,0,3), ", ") . " (+" . tostring(mvcount(countries)-3) . " more)",
        mvjoin(countries, ", ")
    )
| eval attack_type_list=mvsort(mvdedup(all_attack_types))
| eval attack_summary=if(
        mvcount(attack_type_list)>5,
        mvjoin(mvindex(attack_type_list,0,4), "; ") . "; (+" . tostring(mvcount(attack_type_list)-5) . " more)",
        mvjoin(attack_type_list, "; ")
    )
| where peak_rps >= 100
| sort - peak_rps
| table geo.asn, peak_rps_fmt, severity, requests_fmt, unique_ips, country_summary, first_seen_str, last_seen_str, duration_min, unique_targets, attack_summary
| rename 
        geo.asn as "ASN",
        peak_rps_fmt as "Peak RPS",
        severity as "Severity",
        requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        country_summary as "Countries",
        first_seen_str as "First Seen",
        last_seen_str as "Last Seen",
        duration_min as "Duration (min)",
        unique_targets as "Unique Targets",
        attack_summary as "Attack Types"



index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval user_agent=coalesce(user_agent,"N/A"), attack_type=trim(attack_type)
| bin _time span=1m
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        dc(httpMessage.host) as bucket_unique_targets
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/60,2)
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        values(bucket_countries) as countries
        values(bucket_attack_types) as all_attack_types
        min(_time) as first_seen
        max(_time) as last_seen
    by geo.asn
| eval duration_sec=last_seen - first_seen + 60
| eval severity=case(
        peak_rps >= 100000, "CRITICAL",
        peak_rps >= 10000, "HIGH",
        peak_rps >= 1000, "MEDIUM",
        peak_rps >= 100, "LOW",
        1=1, "NORMAL"
    )
| eval first_seen_str=strftime(first_seen, "%Y-%m-%d %H:%M UTC")
| eval last_seen_str=strftime(last_seen, "%Y-%m-%d %H:%M UTC")
| eval duration_min=round(duration_sec/60,1)
| eval requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval country_summary=if(
        mvcount(countries)>4,
        mvjoin(mvindex(countries,0,3), ", ") . " (+" . tostring(mvcount(countries)-3) . " more)",
        mvjoin(countries, ", ")
    )
| eval attack_type_list=mvsort(mvdedup(all_attack_types))
| eval attack_summary=if(
        mvcount(attack_type_list)>5,
        mvjoin(mvindex(attack_type_list,0,4), "; ") . "; (+" . tostring(mvcount(attack_type_list)-5) . " more)",
        mvjoin(attack_type_list, "; ")
    )
| where peak_rps >= 100
| sort - peak_rps
| table geo.asn, peak_rps_fmt, severity, requests_fmt, unique_ips, country_summary, first_seen_str, last_seen_str, duration_min, unique_targets, attack_summary
| rename 
        geo.asn as "ASN",
        peak_rps_fmt as "Peak RPS",
        severity as "Severity",
        requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        country_summary as "Countries",
        first_seen_str as "First Seen",
        last_seen_str as "Last Seen",
        duration_min as "Duration (min)",
        unique_targets as "Unique Targets",
        attack_summary as "Attack Types"




index=akami earliest=-14d@d latest=now
| rex field=httpMessage.requestHeaders "User-Agent:\s+(?<user_agent>[^\r\n]+)"
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/30,2)
| where bucket_rps >= 100
| sort 0 geo.asn, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval gap=_time - prev_time
| eval new_attack=if(isnull(prev_time) OR gap > 300, 1, 0)
| streamstats sum(new_attack) as attack_id by geo.asn
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_attack_types) as all_attack_types
        min(_time) as attack_start
        max(_time) as attack_end
    by geo.asn, attack_id
| eval duration_sec = attack_end - attack_start + 30
| eval avg_rps_session = round(total_requests / duration_sec, 2)
| eval severity = case(
        peak_rps >= 100000, "CRITICAL",
        peak_rps >= 10000, "HIGH",
        peak_rps >= 1000, "MEDIUM",
        peak_rps >= 100, "LOW",
        1=1, "NORMAL"
    )
| eval attack_start_str = strftime(attack_start, "%Y-%m-%d %H:%M UTC")
| eval attack_end_str = strftime(attack_end, "%Y-%m-%d %H:%M UTC")
| eval duration_min = round(duration_sec/60, 1)
| eval total_requests_fmt = tostring(total_requests, "commas")
| eval peak_rps_fmt = tostring(peak_rps, "commas")
| eval avg_rps_fmt = tostring(avg_rps_session, "commas")
| eval countries_summary = if(
        mvcount(countries) > 4,
        mvjoin(mvindex(countries, 0, 3), ", ") + " (+" + tostring(mvcount(countries) - 4, "commas") + " more)",
        mvjoin(countries, ", ")
    )
| eval host_summary = if(
        mvcount(hosts) > 2,
        mvindex(hosts, 0) + ", " + mvindex(hosts, 1) + " (+" + tostring(mvcount(hosts) - 2, "commas") + " more)",
        mvjoin(hosts, ", ")
    )
| eval attack_type_list = mvsort(mvdedup(all_attack_types))
| eval attack_summary = if(
        mvcount(attack_type_list) > 5,
        mvjoin(mvindex(attack_type_list, 0, 4), "; ") + "; (+" + tostring(mvcount(attack_type_list) - 5, "commas") + " more)",
        mvjoin(attack_type_list, "; ")
    )
| sort - peak_rps
| table geo.asn, attack_start_str, attack_end_str, duration_min, peak_rps_fmt, avg_rps_fmt, severity, total_requests_fmt, unique_ips, countries_summary, host_summary, attack_summary
| rename 
        geo.asn as "ASN",
        attack_start_str as "Attack Start",
        attack_end_str as "Attack End",
        duration_min as "Duration (min)",
        peak_rps_fmt as "Peak RPS (30s bucket)",
        avg_rps_fmt as "Avg RPS (session)",
        severity as "Severity",
        total_requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        countries_summary as "Countries",
        host_summary as "Primary Targets",
        attack_summary as "Attack Types"



index=akami
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| bin _time span=30s
| stats count as bucket_requests
        values(attackData.clientIP) as bucket_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| where bucket_rps >= 1000
| sort 0 geo.asn, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap > 300, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        values(bucket_ips) as ips
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_attack_types) as attack_types
        min(_time) as session_start
        max(_time) as session_end
    by geo.asn, session_id
| eval duration_sec = session_end - session_start + 30
| eval avg_rps_session = round(total_requests / duration_sec, 2)
| eval unique_ips = mvcount(mvdedup(ips))
| eval unique_targets = mvcount(mvdedup(hosts))
| eval severity = case(
        peak_rps >= 100000, "CRITICAL",
        peak_rps >= 10000,  "HIGH",
        peak_rps >= 1000,   "MEDIUM",
        1=1,                "LOW"
    )
| eval session_start_str = strftime(session_start, "%Y-%m-%d %H:%M:%S UTC")
| eval session_end_str = strftime(session_end, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min = round(duration_sec / 60, 2)
| eval total_requests_fmt = tostring(total_requests, "commas")
| eval peak_rps_fmt = tostring(peak_rps, "commas")
| eval avg_rps_fmt = tostring(avg_rps_session, "commas")
| eval countries_summary = if(
        mvcount(countries) > 4,
        mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(mvcount(countries) - 4, "commas") . " more)",
        mvjoin(countries, ", ")
    )
| eval host_mv = mvdedup(hosts)
| eval host_summary = if(
        unique_targets > 2,
        mvindex(host_mv, 0) . ", " . mvindex(host_mv, 1) . " (+" . tostring(unique_targets - 2, "commas") . " more)",
        mvjoin(host_mv, ", ")
    )
| eval attack_type_list = mvsort(mvdedup(attack_types))
| eval attack_summary = if(
        mvcount(attack_type_list) > 5,
        mvjoin(mvindex(attack_type_list, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_type_list) - 5, "commas") . " more)",
        mvjoin(attack_type_list, "; ")
    )
| sort - peak_rps
| table geo.asn, session_start_str, session_end_str, duration_min, peak_rps_fmt, avg_rps_fmt, severity, total_requests_fmt, unique_ips, unique_targets, countries_summary, host_summary, attack_summary
| rename 
        geo.asn as "ASN",
        session_start_str as "Attack Start",
        session_end_str as "Attack End",
        duration_min as "Duration (min)",
        peak_rps_fmt as "Peak RPS (30s)",
        avg_rps_fmt as "Avg RPS (session)",
        severity as "Severity",
        total_requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        unique_targets as "Unique Targets",
        countries_summary as "Countries",
        host_summary as "Primary Targets",
        attack_summary as "Attack Types"


index=akami
| rex field=attackData.rules{}.message "(?<attack_type>^[^(|]+)"
| eval attack_type=trim(attack_type)
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        dc(httpMessage.host) as bucket_unique_targets
        values(geo.country) as bucket_countries
        values(attack_type) as bucket_attack_types
    by geo.asn, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| sort 0 geo.asn, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn
| eval gap=_time - prev_time
| eval new_attack=if(isnull(prev_time) OR gap > 300, 1, 0)
| streamstats sum(new_attack) as attack_id by geo.asn
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        values(bucket_countries) as countries
        values(bucket_attack_types) as all_attack_types
        min(_time) as attack_start
        max(_time) as attack_end
    by geo.asn, attack_id
| eval duration_sec = attack_end - attack_start + 30
| eval avg_rps_session = round(total_requests / duration_sec, 2)
| eval severity = case(
        peak_rps >= 100000, "CRITICAL",
        peak_rps >= 10000,  "HIGH",
        peak_rps >= 1000,   "MEDIUM",
        peak_rps >= 100,    "LOW",
        1=1,                "NORMAL"
    )
| eval attack_start_str = strftime(attack_start, "%Y-%m-%d %H:%M:%S UTC")
| eval attack_end_str   = strftime(attack_end,   "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min     = round(duration_sec/60, 2)
| eval total_requests_fmt = tostring(total_requests, "commas")
| eval peak_rps_fmt       = tostring(peak_rps, "commas")
| eval avg_rps_fmt        = tostring(avg_rps_session, "commas")
| eval countries_summary = if(
        mvcount(countries) > 4,
        mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(mvcount(countries) - 4, "commas") . " more)",
        mvjoin(countries, ", ")
    )
| eval attack_type_list = mvsort(mvdedup(all_attack_types))
| eval attack_summary = if(
        mvcount(attack_type_list) > 5,
        mvjoin(mvindex(attack_type_list, 0, 4), "; ") . "; (+" . tostring(mvcount(attack_type_list) - 5, "commas") . " more)",
        mvjoin(attack_type_list, "; ")
    )
| where peak_rps >= 100
| sort - peak_rps
| table geo.asn, attack_start_str, attack_end_str, duration_min, peak_rps_fmt, avg_rps_fmt, severity, total_requests_fmt, unique_ips, unique_targets, countries_summary, attack_summary
| rename
    geo.asn            as "ASN",
    attack_start_str   as "Attack Start",
    attack_end_str     as "Attack End",
    duration_min       as "Duration (min)",
    peak_rps_fmt       as "Peak RPS (30s)",
    avg_rps_fmt        as "Avg RPS (session)",
    severity           as "Severity",
    total_requests_fmt as "Total Requests",
    unique_ips         as "Unique IPs",
    unique_targets     as "Unique Targets",
    countries_summary  as "Countries",
    attack_summary     as "Attack Types"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.action) as bucket_actions
        values(attackData.rules{}.data) as bucket_rule_data
        values(identity.tlsFingerprintV3) as bucket_tlsfp
    by geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as host_p95 by httpMessage.host
| eval hot=if(bucket_rps>=1000 OR bucket_rps>=host_p95*3, 1, 0)
| where hot=1
| sort 0 geo.asn, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>300, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_tlsfp) as tlsfp
        dc(bucket_tlsfp) as tls_fp_count
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_actions) as actions
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, httpMessage.host, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval severity=case(peak_rps>=100000, "CRITICAL", peak_rps>=10000, "HIGH", peak_rps>=1000, "MEDIUM", peak_rps>=100, "LOW", 1=1, "NORMAL")
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval countries_summary=if(mvcount(countries)>4, mvjoin(mvindex(countries,0,3), ", ") . " (+" . tostring(mvcount(countries)-4, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5, mvjoin(mvindex(tags_list,0,4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)", mvjoin(tags_list, "; "))
| eval actions_summary=mvjoin(mvsort(mvdedup(actions)), "; ")
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5, mvjoin(mvindex(rules_list,0,4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)", mvjoin(rules_list, "; "))
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn, httpMessage.host, start_str, stop_str, duration_min, peak_rps_fmt, avg_rps_fmt, severity, total_requests_fmt, unique_ips, tls_fp_count, countries_summary, tags_summary, actions_summary, rules_summary
| rename geo.asn as "ASN",
        httpMessage.host as "Target Host",
        start_str as "Start",
        stop_str as "End",
        duration_min as "Duration (min)",
        peak_rps_fmt as "Peak RPS",
        avg_rps_fmt as "Avg RPS",
        severity as "Severity",
        total_requests_fmt as "Total Requests",
        unique_ips as "Unique IPs",
        tls_fp_count as "TLS FP Count",
        countries_summary as "Countries",
        tags_summary as "Tags",
        actions_summary as "Actions",
        rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.action) as bucket_actions
        values(identity.tlsFingerprintV3) as bucket_tlsfp
    by geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>300, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        dc(bucket_tlsfp) as tls_fp_count
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_actions) as actions
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, httpMessage.host, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval severity=case(peak_rps>=100000, "CRITICAL", peak_rps>=10000, "HIGH", peak_rps>=1000, "MEDIUM", peak_rps>=100, "LOW", 1=1, "NORMAL")
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval countries_summary=if(mvcount(countries)>4, mvjoin(mvindex(countries,0,3), ", ") . " (+" . tostring(mvcount(countries)-4, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5, mvjoin(mvindex(tags_list,0,4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)", mvjoin(tags_list, "; "))
| eval actions_summary=mvjoin(mvsort(mvdedup(actions)), "; ")
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5, mvjoin(mvindex(rules_list,0,4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)", mvjoin(rules_list, "; "))
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn httpMessage.host start_str stop_str duration_min peak_rps_fmt avg_rps_fmt severity total_requests_fmt unique_ips tls_fp_count countries_summary tags_summary actions_summary rules_summary
| rename geo.asn as "ASN" httpMessage.host as "Target Host" start_str as "Start" stop_str as "End" duration_min as "Duration (min)" peak_rps_fmt as "Peak RPS" avg_rps_fmt as "Avg RPS" severity as "Severity" total_requests_fmt as "Total Requests" unique_ips as "Unique IPs" tls_fp_count as "TLS FP Count" countries_summary as "Countries" tags_summary as "Tags" actions_summary as "Actions" rules_summary as "Rule IDs"


index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.action) as bucket_actions
        values(identity.tlsFingerprintV3) as bucket_tlsfp
    by geo.asn, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>300, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        dc(bucket_tlsfp) as tls_fp_count
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_actions) as actions
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, httpMessage.host, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval severity=case(peak_rps>=100000, "CRITICAL", peak_rps>=10000, "HIGH", peak_rps>=1000, "MEDIUM", peak_rps>=100, "LOW", 1=1, "NORMAL")
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval countries_summary=if(mvcount(countries)>4, mvjoin(mvindex(countries, 0, 3), ", ") . " (+" . tostring(mvcount(countries)-4, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5, mvjoin(mvindex(tags_list, 0, 4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)", mvjoin(tags_list, "; "))
| eval actions_summary=mvjoin(mvsort(mvdedup(actions)), "; ")
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5, mvjoin(mvindex(rules_list, 0, 4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)", mvjoin(rules_list, "; "))
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn httpMessage.host start_str stop_str duration_min peak_rps_fmt avg_rps_fmt severity total_requests_fmt unique_ips tls_fp_count countries_summary tags_summary actions_summary rules_summary
| rename geo.asn as "ASN", httpMessage.host as "Target Host", start_str as "Start", stop_str as "End", duration_min as "Duration (min)", peak_rps_fmt as "Peak RPS", avg_rps_fmt as "Avg RPS", severity as "Severity", total_requests_fmt as "Total Requests", unique_ips as "Unique IPs", tls_fp_count as "TLS FP Count", countries_summary as "Countries", tags_summary as "Tags", actions_summary as "Actions", rules_summary as "Rule IDs"




index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| rex field=httpMessage.requestHeaders "User-Agent:\s*(?<user_agent>[^\r\n]+)"
| eval ua_family=lower(replace(user_agent, "\d+(\.\d+)*", ""))
| eval ua_family=replace(ua_family, "[\s/;:_-]+", " ")
| eval ua_family=trim(ua_family)
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
        values(attackData.rules{}.action) as bucket_actions
    by geo.asn, ua_family, identity.tlsFingerprintV3, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, ua_family, identity.tlsFingerprintV3
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, ua_family, identity.tlsFingerprintV3, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, ua_family, identity.tlsFingerprintV3
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, ua_family, identity.tlsFingerprintV3
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_hosts) as hosts
        dc(bucket_hosts) as unique_targets
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_actions) as actions
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, ua_family, identity.tlsFingerprintV3, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries, 0, 4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_summary=mvjoin(mvindex(mvsort(mvdedup(tags)), 0, 4), "; ")
| eval actions_summary=mvjoin(mvsort(mvdedup(actions)), "; ")
| eval rules_summary=mvjoin(mvindex(mvsort(mvdedup(rule_ids)), 0, 4), "; ")
| eval severity=case(peak_rps>=100000, "CRITICAL", peak_rps>=10000, "HIGH", peak_rps>=1000, "MEDIUM", peak_rps>=100, "LOW", 1=1, "NORMAL")
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn ua_family identity.tlsFingerprintV3 start_str stop_str duration_min peak_rps_fmt avg_rps_fmt severity total_requests_fmt unique_ips unique_targets countries_summary tags_summary actions_summary rules_summary
| rename geo.asn as "ASN" ua_family as "UA Family" identity.tlsFingerprintV3 as "TLS FP" start_str as "Start" stop_str as "End" duration_min as "Duration (min)" peak_rps_fmt as "Peak RPS" avg_rps_fmt as "Avg RPS" total_requests_fmt as "Total Requests" unique_ips as "Unique IPs" unique_targets as "Unique Targets" countries_summary as "Countries" tags_summary as "Tags" actions_summary as "Actions" rules_summary as "Rule IDs"


index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        dc(httpMessage.host) as bucket_unique_targets
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by geo.asn, identity.tlsFingerprintV3, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, identity.tlsFingerprintV3
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, identity.tlsFingerprintV3, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, identity.tlsFingerprintV3
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, identity.tlsFingerprintV3
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, identity.tlsFingerprintV3, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval host_mv=mvdedup(hosts)
| eval primary_targets=if(mvcount(host_mv)>3,
                         mvjoin(mvindex(host_mv,0,2), ", ") . " (+" . tostring(mvcount(host_mv)-3, "commas") . " more)",
                         mvjoin(host_mv, ", "))
| eval countries_summary=if(mvcount(countries)>5,
                            mvjoin(mvindex(countries,0,4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)",
                            mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5,
                       mvjoin(mvindex(tags_list,0,4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)",
                       mvjoin(tags_list, "; "))
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5,
                        mvjoin(mvindex(rules_list,0,4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)",
                        mvjoin(rules_list, "; "))
| eval severity=case(peak_rps>=100000, "CRITICAL",
                     peak_rps>=10000,  "HIGH",
                     peak_rps>=1000,   "MEDIUM",
                     peak_rps>=100,    "LOW",
                     1=1,              "NORMAL")
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn identity.tlsFingerprintV3 start_str stop_str duration_min peak_rps_fmt avg_rps_fmt severity total_requests_fmt unique_ips unique_targets primary_targets countries_summary tags_summary rules_summary
| rename geo.asn as "ASN"
        identity.tlsFingerprintV3 as "TLS FP"
        start_str as "Start"
        stop_str as "End"
        duration_min as "Duration (min)"
        peak_rps_fmt as "Peak RPS"
        avg_rps_fmt as "Avg RPS"
        total_requests_fmt as "Total Requests"
        unique_ips as "Unique IPs"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        dc(httpMessage.host) as bucket_unique_targets
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by geo.asn, identity.tlsFingerprintV3, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, identity.tlsFingerprintV3
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, identity.tlsFingerprintV3, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, identity.tlsFingerprintV3
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, identity.tlsFingerprintV3
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        max(bucket_unique_targets) as unique_targets
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, identity.tlsFingerprintV3, session_id
| eval duration_sec=stop - start + 30
| eval avg_rps_session=round(total_requests/duration_sec, 2)
| eval start_str=strftime(start, "%Y-%m-%d %H:%M:%S UTC")
| eval stop_str=strftime(stop, "%Y-%m-%d %H:%M:%S UTC")
| eval duration_min=round(duration_sec/60, 1)
| eval total_requests_fmt=tostring(total_requests, "commas")
| eval peak_rps_fmt=tostring(peak_rps, "commas")
| eval avg_rps_fmt=tostring(avg_rps_session, "commas")
| eval host_mv=mvdedup(hosts)
| eval primary_targets=if(mvcount(host_mv)>3, mvjoin(mvindex(host_mv,0,2), ", ") . " (+" . tostring(mvcount(host_mv)-3, "commas") . " more)", mvjoin(host_mv, ", "))
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries,0,4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5, mvjoin(mvindex(tags_list,0,4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)", mvjoin(tags_list, "; "))
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5, mvjoin(mvindex(rules_list,0,4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)", mvjoin(rules_list, "; "))
| eval severity=case(peak_rps>=100000, "CRITICAL", peak_rps>=10000, "HIGH", peak_rps>=1000, "MEDIUM", peak_rps>=100, "LOW", 1=1, "NORMAL")
| where peak_rps>=100 OR total_requests>=10000
| sort - peak_rps
| table geo.asn identity.tlsFingerprintV3 start_str stop_str duration_min peak_rps_fmt avg_rps_fmt severity total_requests_fmt unique_ips unique_targets primary_targets countries_summary tags_summary rules_summary
| rename geo.asn as "ASN" identity.tlsFingerprintV3 as "TLS FP" start_str as "Start" stop_str as "End" duration_min as "Duration (min)" peak_rps_fmt as "Peak RPS" avg_rps_fmt as "Avg RPS" total_requests_fmt as "Total Requests" unique_ips as "Unique IPs" unique_targets as "Unique Targets" primary_targets as "Primary Targets" countries_summary as "Countries" tags_summary as "Tags" rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by geo.asn, identity.tlsFingerprintV3, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, identity.tlsFingerprintV3, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, identity.tlsFingerprintV3, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, identity.tlsFingerprintV3, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, identity.tlsFingerprintV3, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, identity.tlsFingerprintV3, session_id
| eval duration_sec=stop - start + 30
| eval session_hosts=hosts
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as peak_rps_max
        sum(duration_sec) as active_sec
        count as sessions
        sum(unique_ips) as unique_ips_est
        values(session_hosts) as all_hosts
        values(countries) as countries
        values(tags) as tags
        values(rule_ids) as rule_ids
        min(start) as first_seen
        max(stop) as last_seen
    by geo.asn, identity.tlsFingerprintV3
| eval overall_rps=round(total_requests_all/active_sec, 2)
| eval active_min=round(active_sec/60, 1)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3, mvjoin(mvindex(hosts_flat, 0, 2), ", ") . " (+" . tostring(unique_targets-3, "commas") . " more)", mvjoin(hosts_flat, ", "))
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries, 0, 4), ", ") . " (+" . tostring(mvcount(countries)-5, "commas") . " more)", mvjoin(countries, ", "))
| eval tags_list=mvsort(mvdedup(tags))
| eval tags_summary=if(mvcount(tags_list)>5, mvjoin(mvindex(tags_list, 0, 4), "; ") . "; (+" . tostring(mvcount(tags_list)-5, "commas") . " more)", mvjoin(tags_list, "; "))
| eval rules_list=mvsort(mvdedup(rule_ids))
| eval rules_summary=if(mvcount(rules_list)>5, mvjoin(mvindex(rules_list, 0, 4), "; ") . "; (+" . tostring(mvcount(rules_list)-5, "commas") . " more)", mvjoin(rules_list, "; "))
| eval severity=case(peak_rps_max>=100000, "CRITICAL", peak_rps_max>=10000, "HIGH", peak_rps_max>=1000, "MEDIUM", peak_rps_max>=100, "LOW", 1=1, "NORMAL")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval peak_rps_fmt=tostring(peak_rps_max, "commas")
| eval overall_rps_fmt=tostring(overall_rps, "commas")
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| where peak_rps_max>=100 OR total_requests_all>=10000
| sort - peak_rps_max
| table geo.asn identity.tlsFingerprintV3 first_str last_str active_min sessions peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_ips_est unique_targets primary_targets countries_summary tags_summary rules_summary
| rename geo.asn as "ASN" identity.tlsFingerprintV3 as "TLS FP" first_str as "First Seen" last_str as "Last Seen" active_min as "Active (min)" sessions as "Sessions" peak_rps_fmt as "Max Peak RPS" overall_rps_fmt as "Overall RPS" total_requests_fmt as "Total Requests" unique_ips_est as "Unique IPs (est)" unique_targets as "Unique Targets" primary_targets as "Primary Targets" countries_summary as "Countries" tags_summary as "Tags" rules_summary as "Rule IDs"



index=network_long sourcetype=akamai:apikona:json wf_id=AKAMAI
| eval tls_fp=coalesce(identity.tlsFingerprintV3, identity.tlsFingerprintV2, "unknown")
| bin _time span=30s
| stats count as bucket_requests
        dc(attackData.clientIP) as bucket_unique_ips
        values(httpMessage.host) as bucket_hosts
        values(geo.country) as bucket_countries
        values(attackData.rules{}.tag) as bucket_tags
        values(attackData.rules{}.id) as bucket_rule_ids
    by geo.asn, tls_fp, httpMessage.host, _time
| eval bucket_rps=round(bucket_requests/30, 2)
| eventstats p95(bucket_rps) as key_p95 p99(bucket_rps) as key_p99 by geo.asn, tls_fp, httpMessage.host
| eval spike=if(bucket_rps>=1000 OR bucket_rps>=key_p95*3 OR bucket_rps>=key_p99*1.5, 1, 0)
| where spike=1
| sort 0 geo.asn, tls_fp, httpMessage.host, _time
| streamstats current=f window=1 last(_time) as prev_time by geo.asn, tls_fp, httpMessage.host
| eval gap=_time - prev_time
| eval new_session=if(isnull(prev_time) OR gap>600, 1, 0)
| streamstats sum(new_session) as session_id by geo.asn, tls_fp, httpMessage.host
| stats sum(bucket_requests) as total_requests
        max(bucket_rps) as peak_rps
        avg(bucket_rps) as avg_rps
        max(bucket_unique_ips) as unique_ips
        values(bucket_hosts) as hosts
        values(bucket_countries) as countries
        values(bucket_tags) as tags
        values(bucket_rule_ids) as rule_ids
        min(_time) as start
        max(_time) as stop
    by geo.asn, tls_fp, httpMessage.host, session_id
| eval session_sec=stop - start + 30
| eval session_min=round(session_sec/60, 1)
| stats sum(total_requests) as total_requests_all
        max(peak_rps) as max_peak_rps
        avg(avg_rps) as avg_rps_mean
        sum(session_sec) as total_active_sec
        avg(session_min) as avg_session_min
        max(session_min) as max_session_min
        count as session_count
        values(hosts) as all_hosts
        values(countries) as countries
        values(tags) as tags
        values(rule_ids) as rule_ids
        min(start) as first_seen
        max(stop) as last_seen
    by geo.asn, tls_fp
| eval campaign_span_min=round((last_seen - first_seen)/60, 1)
| eval total_active_min=round(total_active_sec/60, 1)
| eval overall_rps=round(total_requests_all/total_active_sec, 2)
| eval hosts_flat=mvdedup(all_hosts)
| eval unique_targets=mvcount(hosts_flat)
| eval primary_targets=if(unique_targets>3, mvjoin(mvindex(hosts_flat, 0, 2), ", ") + " (+" + tostring(unique_targets-3, "commas") + " more)", mvjoin(hosts_flat, ", "))
| eval countries_summary=if(mvcount(countries)>5, mvjoin(mvindex(countries, 0, 4), ", ") + " (+" + tostring(mvcount(countries)-5, "commas") + " more)", mvjoin(countries, ", "))
| eval tags_summary=mvjoin(mvindex(mvsort(mvdedup(tags)), 0, 4), "; ")
| eval rules_summary=mvjoin(mvindex(mvsort(mvdedup(rule_ids)), 0, 4), "; ")
| eval severity=case(max_peak_rps>=100000, "CRITICAL", max_peak_rps>=10000, "HIGH", max_peak_rps>=1000, "MEDIUM", max_peak_rps>=100, "LOW", 1=1, "NORMAL")
| eval total_requests_fmt=tostring(total_requests_all, "commas")
| eval max_peak_rps_fmt=tostring(max_peak_rps, "commas")
| eval overall_rps_fmt=tostring(overall_rps, "commas")
| eval first_str=strftime(first_seen, "%Y-%m-%d %H:%M:%S UTC")
| eval last_str=strftime(last_seen, "%Y-%m-%d %H:%M:%S UTC")
| where max_peak_rps>=100 OR total_requests_all>=10000
| sort - max_peak_rps
| table geo.asn tls_fp first_str last_str campaign_span_min total_active_min session_count avg_session_min max_session_min max_peak_rps_fmt overall_rps_fmt severity total_requests_fmt unique_targets primary_targets countries_summary tags_summary rules_summary
| rename geo.asn as "ASN"
        tls_fp as "TLS FP"
        first_str as "First Seen"
        last_str as "Last Seen"
        campaign_span_min as "Span (min)"
        total_active_min as "Active (min)"
        session_count as "Sessions"
        avg_session_min as "Avg Session (min)"
        max_session_min as "Max Session (min)"
        max_peak_rps_fmt as "Max Peak RPS"
        overall_rps_fmt as "Overall RPS"
        total_requests_fmt as "Total Requests"
        unique_targets as "Unique Targets"
        primary_targets as "Primary Targets"
        countries_summary as "Countries"
        tags_summary as "Tags"
        rules_summary as "Rule IDs"
