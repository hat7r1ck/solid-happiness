let
    // -----------------------------
    // DIALS
    // -----------------------------
    EffortPerCaseHours = 1.0,
    EffortPerPointHours = 0.5,
    PickupMinThreshold = 45,   // minutes
    CloseMinThreshold = 45,    // minutes

    IncludeStatuses = {"Active", "Rotational", "Onboarding"},

    UtilYellowFloor = 0.60,
    UtilRedFloor = 0.80,

    // Kingman inputs (SCV)
    Ca2 = 1.0,
    Cs2 = 1.0,

    // Exec filter
    FilterOnlyLocations = true,
    OnlyLocations = {"Chandler", "Charlotte", "India"},

    // -----------------------------
    // SOURCE PICKER (tries MttR_hours first, then Column_Trim)
    // -----------------------------
    IncSource =
        let
            a = try MttR_hours
        in
            if a[HasError] then
                let
                    b = try Column_Trim
                in
                    if b[HasError] then
                        error "Could not find incident source query. Expected MttR_hours or Column_Trim."
                    else
                        b[Value]
            else
                a[Value],

    // -----------------------------
    // HELPERS
    // -----------------------------
    FxText = (v as any) as text =>
        if v = null then "" else Text.Trim(Text.From(v)),

    FxHasText = (v as any) as logical =>
        let t = FxText(v)
        in if t = "" then false else true,

    FxNum = (v as any) as nullable number =>
        let n = try Number.From(v) otherwise null
        in n,

    FxDT = (v as any) as nullable datetime =>
        let d = try DateTime.From(v) otherwise null
        in d,

    FxDate = (v as any) as nullable date =>
        let d = try Date.From(v) otherwise null
        in d,

    FxHours = (start as nullable datetime, finish as nullable datetime) as nullable number =>
        if start = null then
            null
        else if finish = null then
            null
        else
            let
                delta = finish - start,
                h = try Duration.TotalHours(delta) otherwise null
            in
                if h = null then null
                else if h < 0 then null
                else h,

    NormalizeSite = (s as any) as nullable text =>
        let
            raw = Text.Lower(FxText(s)),
            compact = Text.Select(raw, {"a".."z", "0".."9", " "}),
            isChandler =
                Text.Contains(compact, "chand")
                    or compact = "az"
                    or compact = "arizona"
                    or Text.Contains(compact, " arizona")
                    or Text.Contains(compact, " az "),
            isCharlotte =
                Text.Contains(compact, "charl")
                    or compact = "nc"
                    or Text.Contains(compact, "north carolina")
                    or Text.Contains(compact, " nc "),
            isIndia =
                compact = "in"
                    or Text.Contains(compact, "india")
        in
            if compact = "" then null
            else if isChandler then "Chandler"
            else if isCharlotte then "Charlotte"
            else if isIndia then "India"
            else null,

    // shift day token normalization
    DayMap = [
        monday = "mon", mon = "mon", mo = "mon",
        tuesday = "tue", tue = "tue", tu = "tue",
        wednesday = "wed", wed = "wed", we = "wed",
        thursday = "thu", thu = "thu", th = "thu",
        friday = "fri", fri = "fri", fr = "fri",
        saturday = "sat", sat = "sat", sa = "sat",
        sunday = "sun", sun = "sun", su = "sun"
    ],

    NormalizeDayToken = (t as text) as nullable text =>
        let
            x = Text.Select(Text.Lower(Text.Trim(t)), {"a".."z"}),
            mapped = Record.FieldOrDefault(DayMap, x, null)
        in
            mapped,

    SplitDays = (s as any) as list =>
        let
            raw = Text.Lower(FxText(s)),
            cleaned =
                Text.Replace(
                    Text.Replace(
                        Text.Replace(
                            Text.Replace(raw, ".", " "),
                        ";", " "),
                    "/", " "),
                "|", " "),
            tokens = List.RemoveItems(Text.SplitAny(cleaned, " ,"), {""}),
            norm = List.RemoveNulls(List.Transform(tokens, each NormalizeDayToken(_)))
        in
            List.Distinct(norm),

    // safe record field
    GetField = (r as record, f as text) as any =>
        try Record.Field(r, f) otherwise null,

    HasCol = (t as table, c as text) as logical =>
        List.Contains(Table.ColumnNames(t), c),

    // -----------------------------
    // SHIFT TABLE (capacity + owner->location map)
    // -----------------------------
    ShiftRaw = Excel.CurrentWorkbook(){[Name = "shift"]}[Content],

    ShiftTyped =
        Table.TransformColumnTypes(
            ShiftRaw,
            {
                {"id", type text},
                {"Team Name", type text},
                {"Location", type text},
                {"Hours", type number},
                {"Day Type", type text},
                {"Shift Days", type text},
                {"Status", type text}
            }
        ),

    ShiftNorm =
        Table.TransformColumns(
            ShiftTyped,
            {
                {"id", each Text.Lower(Text.Trim(FxText(_))), type text},
                {"Team Name", each Text.Trim(FxText(_)), type text},
                {"Location", each Text.Trim(FxText(_)), type text},
                {"Day Type", each Text.Upper(Text.Trim(FxText(_))), type text},
                {"Shift Days", each Text.Lower(Text.Trim(FxText(_))), type text},
                {"Status", each Text.Proper(Text.Trim(FxText(_))), type text}
            }
        ),

    StaffMap =
        Table.Distinct(
            Table.SelectColumns(ShiftNorm, {"id", "Team Name", "Location"})
        ),

    Shift_Filtered =
        Table.SelectRows(
            ShiftNorm,
            each
                if [Status] = null then false
                else List.Contains(IncludeStatuses, [Status])
        ),

    Shift_WithDaysList =
        Table.AddColumn(
            Shift_Filtered,
            "DayAbbrev",
            each SplitDays([Shift Days]),
            type list
        ),

    Shift_DOH = Table.ExpandListColumn(Shift_WithDaysList, "DayAbbrev"),

    Shift_CapacityKeys =
        Table.SelectColumns(
            Table.TransformColumns(
                Shift_DOH,
                {
                    {"Day Type", each Text.Upper(Text.Trim(FxText(_))), type text},
                    {"DayAbbrev", each Text.Lower(Text.Trim(FxText(_))), type text},
                    {"Location", each Text.Trim(FxText(_)), type text},
                    {"Hours", each FxNum(_), type nullable number}
                }
            ),
            {"Location", "Day Type", "DayAbbrev", "Hours"}
        ),

    Cap_BySite =
        Table.Group(
            Shift_CapacityKeys,
            {"Location", "Day Type", "DayAbbrev"},
            {{"CapacityHours", each List.Sum(List.RemoveNulls([Hours])), type number}}
        ),

    Cap_Ready = Table.RenameColumns(Cap_BySite, {{"Day Type", "DayType"}}),

    // -----------------------------
    // INCIDENTS (keep everything needed, do not drop keys prematurely)
    // -----------------------------
    IncCols = Table.ColumnNames(IncSource),

    Inc0 =
        Table.TransformColumns(
            IncSource,
            {
                {"id", each FxText(_), type text},
                {"owner", each Text.Lower(Text.Trim(FxText(_))), type text},
                {"Site", each FxText(_), type text},
                {"Location", each FxText(_), type text}
            },
            MissingField.Ignore
        ),

    // Rename case id to avoid collisions with shift id
    Inc1 =
        Table.RenameColumns(
            Inc0,
            {{"id", "case_id"}},
            MissingField.Ignore
        ),

    // Datetime coercion (safe)
    Inc2 =
        Table.TransformColumns(
            Inc1,
            {
                {"Created Date/Time (UTC)", each FxDT(_), type nullable datetime},
                {"Owner Assignment Time (UTC)", each FxDT(_), type nullable datetime},
                {"Closed Date/Time (UTC)", each FxDT(_), type nullable datetime},
                {"Occurred Date/Time (UTC)", each FxDT(_), type nullable datetime}
            },
            MissingField.Ignore
        ),

    // Join owner -> shift id to get location/team when owner exists
    Inc3 =
        if HasCol(Inc2, "owner") then
            Table.NestedJoin(
                Inc2,
                {"owner"},
                StaffMap,
                {"id"},
                "staff",
                JoinKind.LeftOuter
            )
        else
            Table.AddColumn(Inc2, "staff", each null),

    Inc4 =
        if HasCol(Inc3, "staff") then
            Table.ExpandTableColumn(
                Inc3,
                "staff",
                {"Team Name", "Location"},
                {"TeamName_fromShift", "Location_fromShift"}
            )
        else
            Inc3,

    // Determine LocationFinal in order: shift mapping, existing Location, normalized Site
    Inc5 =
        Table.AddColumn(
            Inc4,
            "LocationFinal",
            each
                let
                    locShift = GetField(_, "Location_fromShift"),
                    locExisting = if HasCol(Inc4, "Location") then GetField(_, "Location") else null,
                    siteVal = if HasCol(Inc4, "Site") then GetField(_, "Site") else null,
                    locSite = NormalizeSite(siteVal),
                    l1 = if FxText(locShift) = "" then null else Text.Trim(FxText(locShift)),
                    l2 = if FxText(locExisting) = "" then null else Text.Trim(FxText(locExisting))
                in
                    if l1 <> null then l1
                    else if l2 <> null then l2
                    else locSite,
            type text
        ),

    // Created date keys
    Inc6 =
        Table.AddColumn(
            Inc5,
            "Created Date",
            each
                let cdt = if HasCol(Inc5, "Created Date/Time (UTC)") then GetField(_, "Created Date/Time (UTC)") else null
                in FxDate(cdt),
            type nullable date
        ),

    Inc7 =
        Table.AddColumn(
            Inc6,
            "DayAbbrev",
            each
                if [Created Date] = null then null
                else Text.Lower(Date.ToText([Created Date], "ddd", "en-US")),
            type text
        ),

    Inc8 =
        Table.AddColumn(
            Inc7,
            "DayType",
            each
                if [Created Date] = null then null
                else if Date.DayOfWeek([Created Date], Day.Monday) >= 5 then "WEEKEND" else "WEEKDAY",
            type text
        ),

    // Optional exec filter (null-safe boolean expression)
    Inc_FilterLoc =
        if FilterOnlyLocations then
            Table.SelectRows(
                Inc8,
                each
                    if [LocationFinal] = null then false
                    else List.Contains(OnlyLocations, [LocationFinal])
            )
        else
            Inc8,

    // Build pickup/close hours from MTT fields if present, otherwise derive from datetimes
    Inc9 =
        Table.AddColumn(
            Inc_FilterLoc,
            "PickupHours",
            each
                let
                    mttPU = if HasCol(Inc_FilterLoc, "MttPU_hours") then FxNum(GetField(_, "MttPU_hours")) else null,
                    created = if HasCol(Inc_FilterLoc, "Created Date/Time (UTC)") then GetField(_, "Created Date/Time (UTC)") else null,
                    assigned = if HasCol(Inc_FilterLoc, "Owner Assignment Time (UTC)") then GetField(_, "Owner Assignment Time (UTC)") else null,
                    derived = FxHours(created, assigned)
                in
                    if mttPU <> null then mttPU else derived,
            type nullable number
        ),

    Inc10 =
        Table.AddColumn(
            Inc9,
            "CloseHours",
            each
                let
                    mttClose = if HasCol(Inc9, "MttClose_hours") then FxNum(GetField(_, "MttClose_hours")) else null,
                    created = if HasCol(Inc9, "Created Date/Time (UTC)") then GetField(_, "Created Date/Time (UTC)") else null,
                    closed = if HasCol(Inc9, "Closed Date/Time (UTC)") then GetField(_, "Closed Date/Time (UTC)") else null,
                    derived = FxHours(created, closed)
                in
                    if mttClose <> null then mttClose else derived,
            type nullable number
        ),

    // Escalation flag (safe booleans only)
    Inc11 =
        Table.AddColumn(
            Inc10,
            "Escalated",
            each
                let
                    e1 = if HasCol(Inc10, "Escalation") then FxHasText(GetField(_, "Escalation")) else false,
                    e2 = if HasCol(Inc10, "Escalation To") then FxHasText(GetField(_, "Escalation To")) else false
                in
                    if e1 then true else if e2 then true else false,
            type logical
        ),

    // Complexity points (no nullable boolean operators)
    Inc12 =
        Table.AddColumn(
            Inc11,
            "ComplexityPoints",
            each
                let
                    pickMin = if [PickupHours] = null then null else [PickupHours] * 60,
                    closeMin = if [CloseHours] = null then null else [CloseHours] * 60,
                    pPickup =
                        if pickMin = null then 0
                        else if pickMin >= PickupMinThreshold then 1
                        else 0,
                    pClose =
                        if closeMin = null then 0
                        else if closeMin >= CloseMinThreshold then 1
                        else 0,
                    pEsc =
                        if [Escalated] = true then 1 else 0
                in
                    pEsc + pPickup + pClose,
            Int64.Type
        ),

    Inc13 =
        Table.AddColumn(
            Inc12,
            "CaseEffortHours",
            each EffortPerCaseHours + Number.From([ComplexityPoints]) * EffortPerPointHours,
            type number
        ),

    // -----------------------------
    // DEMAND (site-level)
    // -----------------------------
    Demand_BySite =
        Table.Group(
            Inc13,
            {"Created Date", "LocationFinal", "DayType", "DayAbbrev"},
            {
                {"Cases", each Table.RowCount(_), Int64.Type},
                {"DemandHours", each List.Sum(List.RemoveNulls([CaseEffortHours])), type number},
                {"Avg_Pickup_h", each try List.Average(List.RemoveNulls([PickupHours])) otherwise null, type nullable number},
                {"Avg_Close_h", each try List.Average(List.RemoveNulls([CloseHours])) otherwise null, type nullable number}
            }
        ),

    Demand_RenameLoc =
        Table.RenameColumns(Demand_BySite, {{"LocationFinal", "Location"}}, MissingField.Ignore),

    // -----------------------------
    // JOIN DEMAND WITH CAPACITY
    // -----------------------------
    JoinDC =
        Table.NestedJoin(
            Demand_RenameLoc,
            {"Location", "DayType", "DayAbbrev"},
            Cap_Ready,
            {"Location", "DayType", "DayAbbrev"},
            "cap",
            JoinKind.LeftOuter
        ),

    WithCap =
        Table.ExpandTableColumn(JoinDC, "cap", {"CapacityHours"}, {"CapacityHours"}),

    // Utilization (null-safe, no nullable boolean operators)
    WithUtil =
        Table.AddColumn(
            WithCap,
            "Utilization",
            each
                let
                    d = FxNum([DemandHours]),
                    c = FxNum([CapacityHours])
                in
                    if d = null then null
                    else if c = null then null
                    else if c = 0 then null
                    else d / c,
            type nullable number
        ),

    WithSvc =
        Table.AddColumn(
            WithUtil,
            "AvgServiceHours",
            each
                let
                    d = FxNum([DemandHours]),
                    n = FxNum([Cases])
                in
                    if d = null then null
                    else if n = null then null
                    else if n = 0 then null
                    else d / n,
            type nullable number
        ),

    WithKingman =
        Table.AddColumn(
            WithSvc,
            "KingmanBurnoutHours",
            each
                let
                    u = FxNum([Utilization]),
                    s = FxNum([AvgServiceHours])
                in
                    if u = null then
                        null
                    else if s = null then
                        null
                    else if u >= 0.99 then
                        null
                    else
                        (u / (1 - u)) * ((Ca2 + Cs2) / 2) * s,
            type nullable number
        ),

    WithIndex =
        Table.AddColumn(
            WithKingman,
            "BurnoutIndex",
            each
                let u = FxNum([Utilization])
                in
                    if u = null then
                        null
                    else if u >= 0.99 then
                        null
                    else
                        u / (1 - u),
            type nullable number
        ),

    WithFlag =
        Table.AddColumn(
            WithIndex,
            "UtilizationFlag",
            each
                let u = FxNum([Utilization])
                in
                    if u = null then
                        "No-capacity"
                    else if u >= UtilRedFloor then
                        "RED 80%+"
                    else if u >= UtilYellowFloor then
                        "YELLOW 60-80%"
                    else
                        "GREEN <60%",
            type text
        ),

    Result =
        Table.TransformColumns(
            WithFlag,
            {
                {"DemandHours", each try Number.Round(_, 2) otherwise _, type nullable number},
                {"CapacityHours", each try Number.Round(_, 2) otherwise _, type nullable number},
                {"Utilization", each try Number.Round(_, 3) otherwise _, type nullable number},
                {"AvgServiceHours", each try Number.Round(_, 3) otherwise _, type nullable number},
                {"KingmanBurnoutHours", each try Number.Round(_, 3) otherwise _, type nullable number},
                {"BurnoutIndex", each try Number.Round(_, 3) otherwise _, type nullable number},
                {"Avg_Pickup_h", each try Number.Round(_, 2) otherwise _, type nullable number},
                {"Avg_Close_h", each try Number.Round(_, 2) otherwise _, type nullable number}
            }
        )
in
    Result
