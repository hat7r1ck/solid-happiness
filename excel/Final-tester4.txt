Option Explicit

' ===============================
' Case Review List Builder (KISS)
' ===============================
' Input supported:
' - Sheet1 plain range with headers in row 1, data under it
' - Sheet1 Excel Table named "T_Raw", paste or append into the table
'
' Behavior:
' - De-duped by id, newest close time wins
' - Manager "Dbot" rows are excluded
' - PriorityFlag: 1 = review first, 0 = normal
' - Closed Date/Time (UTC): visible, blank when missing or "Still Open"
' - Senior Reviewer (col D) dropdown from Sheet2!A2:A...
' - Determination (col E) dropdown: Additional Actions Required, Validated, Coaching, Exemplary
' - Notes (col F) free text
' - Reviewer fields and notes persist per Case ID in hidden InputsStore, not position
' - Core fields persist in hidden PersistStore, so IDs never drop
'
' Admin toggles:
Private Const CLOSED_HDR As String = "Closed Date/Time (UTC)" ' exact header in Sheet1 or T_Raw
Private Const PRESERVE_WIDTHS As Boolean = True               ' True keeps your manual column widths
Private Const BOLD_HEADER As Boolean = True                   ' Bold the header row if True
Private Const NORMALIZE_ID_CASE As Boolean = True             ' True stores ID keys uppercased to avoid case drift

' ===============================
' Entry point
' ===============================
Public Sub BuildCaseReview()
    Dim wsIn As Worksheet, wsOut As Worksheet, wsEng As Worksheet
    Dim inData As Variant
    Dim colId As Long, colOwner As Long, colMgr As Long, colLinked As Long, colName As Long, colType As Long, colClosed As Long
    Dim r As Long, idRaw As String, idKey As String
    Dim dictCurrent As Object ' idKey -> Array(displayId, owner, mgr, prio, closedSerial)
    Dim dictPersist As Object ' idKey -> Array(displayId, owner, mgr, prio, closedSerial)
    Dim dictInputs As Object  ' idKey -> Array(SeniorReviewer, Determination, Notes, UpdatedAtSerial)
    Dim hasClosed As Boolean

    ' Safe app state
    Dim prevCalc As XlCalculation
    prevCalc = Application.Calculation
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    On Error GoTo CleanFail

    ' Ensure required sheets exist
    Set wsIn = SheetByName("Sheet1")
    Set wsOut = SheetByName("Case Review List")
    Set wsEng = SheetByName("Sheet2")

    ' Load persistent stores
    Set dictPersist = LoadPersistStore()
    Set dictInputs = LoadInputsStore()

    ' Ingest current user inputs from existing output, merge into dictInputs by ID
    SnapshotAndMergeUserInputs wsOut, dictInputs

    ' Build an input matrix from either T_Raw or plain range
    inData = GetInputMatrix(wsIn) ' returns Empty if no usable data

    If Not IsEmpty(inData) Then
        ' Locate headers in the matrix, case insensitive
        colId = FindHeader(inData, "id")
        colOwner = FindHeader(inData, "owner")
        colMgr = FindHeader(inData, "Manager")
        colLinked = FindHeader(inData, "linkedCount")
        colName = FindHeader(inData, "name")
        colType = FindHeader(inData, "type")
        colClosed = FindHeader(inData, CLOSED_HDR)
        hasClosed = (colClosed > 0)

        If colId = 0 Or colOwner = 0 Or colMgr = 0 Or colLinked = 0 Or colName = 0 Or colType = 0 Then
            MsgBox "Missing columns in Sheet1 or T_Raw: id, owner, Manager, linkedCount, name, type.", vbExclamation
            GoTo AfterPersistMerge
        End If

        ' Build current dictionary from matrix with de-dupe by id, prefer newest Closed
        Set dictCurrent = CreateObject("Scripting.Dictionary")
        For r = 2 To UBound(inData, 1)
            idRaw = CStr(inData(r, colId))
            idKey = IdKeyOf(idRaw)
            If Len(idKey) = 0 Then GoTo NextR

            Dim ownerVal As String, mgrVal As String, nm As String, ty As String
            Dim linkedVal As Long, prio As Long, dVal As Double

            ownerVal = CStr(inData(r, colOwner))
            mgrVal = CStr(inData(r, colMgr))
            ' exclude rows where Manager is Dbot
            If UCase$(Trim$(mgrVal)) = "DBOT" Then GoTo NextR

            nm = CStr(inData(r, colName))
            ty = CStr(inData(r, colType))
            linkedVal = Val(inData(r, colLinked))
            prio = ComputePriority(linkedVal, nm, ty)
            dVal = IIf(hasClosed, ToExcelDate(inData(r, colClosed)), 0)

            If Not dictCurrent.Exists(idKey) Then
                dictCurrent(idKey) = Array(Trim$(CStr(idRaw)), ownerVal, mgrVal, prio, dVal)
            Else
                Dim cur() As Variant
                cur = dictCurrent(idKey)
                If dVal > CDbl(cur(4)) Then
                    dictCurrent(idKey) = Array(Trim$(CStr(idRaw)), ownerVal, mgrVal, prio, dVal)
                End If
            End If
NextR:
        Next r
    End If

AfterPersistMerge:
    ' Merge current into persistence, prefer newer Closed
    Dim k As Variant, rec() As Variant, oldRec() As Variant
    If Not dictCurrent Is Nothing Then
        For Each k In dictCurrent.Keys
            rec = dictCurrent(k)
            If Not dictPersist.Exists(k) Then
                dictPersist(k) = rec
            Else
                oldRec = dictPersist(k)
                If CDbl(rec(4)) >= CDbl(oldRec(4)) Then
                    dictPersist(k) = rec
                End If
            End If
        Next k
    End If

    ' Save both stores
    SavePersistStore dictPersist
    SaveInputsStore dictInputs

    ' Write Case Review List from persistence and restore inputs
    WriteOutputFromPersist wsOut, dictPersist, dictInputs

    ' Data validation
    EnsureEngineersListName wsEng
    Dim lastOutRow As Long
    lastOutRow = wsOut.Cells(wsOut.Rows.Count, "A").End(xlUp).Row
    If lastOutRow < 2 Then lastOutRow = 2

    With wsOut.Range("D2:D" & lastOutRow).Validation
        .Delete
    End With
    wsOut.Range("D2:D" & lastOutRow).Validation.Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:="=EngineersList"

    With wsOut.Range("E2:E" & lastOutRow).Validation
        .Delete
    End With
    wsOut.Range("E2:E" & lastOutRow).Validation.Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, _
        Formula1:="Additional Actions Required,Validated,Coaching,Exemplary"

    ' Basic formatting
    If BOLD_HEADER Then wsOut.Rows(1).Font.Bold = True
    If Not PRESERVE_WIDTHS Then wsOut.Columns("A:H").AutoFit
    wsOut.Columns("H").NumberFormat = "m/d/yy h:mm AM/PM;;;"

CleanExit:
    Application.Calculation = prevCalc
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Exit Sub

CleanFail:
    Application.Calculation = prevCalc
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    MsgBox "BuildCaseReview stopped: " & Err.Description, vbExclamation
End Sub

' ---------- Input handling ----------

Private Function GetInputMatrix(wsIn As Worksheet) As Variant
    ' Tries T_Raw first, then falls back to headers in row 1
    Dim lo As ListObject
    On Error Resume Next
    Set lo = wsIn.ListObjects("T_Raw")
    On Error GoTo 0

    If Not lo Is Nothing Then
        If lo.HeaderRowRange Is Nothing Then Exit Function
        If lo.DataBodyRange Is Nothing Then
            Dim hdrArr As Variant, cols As Long, tmp() As Variant, c As Long
            hdrArr = lo.HeaderRowRange.Value2
            cols = lo.ListColumns.Count
            ReDim tmp(1 To 1, 1 To cols)
            For c = 1 To cols
                tmp(1, c) = hdrArr(1, c)
            Next c
            GetInputMatrix = tmp
            Exit Function
        End If
        Dim bodyArr As Variant, rows As Long, cols2 As Long, r As Long, c2 As Long, outArr() As Variant
        bodyArr = lo.DataBodyRange.Value2
        rows = UBound(bodyArr, 1)
        cols2 = UBound(bodyArr, 2)
        ReDim outArr(1 To rows + 1, 1 To cols2)
        ' header
        For c2 = 1 To cols2
            outArr(1, c2) = lo.HeaderRowRange.Cells(1, c2).Value2
        Next c2
        ' body
        For r = 1 To rows
            For c2 = 1 To cols2
                outArr(r + 1, c2) = bodyArr(r, c2)
            Next c2
        Next r
        GetInputMatrix = outArr
        Exit Function
    End If

    ' Plain range mode
    Dim lastRow As Long, lastCol As Long
    lastRow = wsIn.Cells(wsIn.Rows.Count, 1).End(xlUp).Row
    If lastRow < 2 Then Exit Function
    lastCol = wsIn.Cells(1, wsIn.Columns.Count).End(xlToLeft).Column
    GetInputMatrix = wsIn.Range(wsIn.Cells(1, 1), wsIn.Cells(lastRow, lastCol)).Value2
End Function

' ---------- Keys, header, priority, dates ----------

Private Function IdKeyOf(ByVal idRaw As String) As String
    Dim s As String
    s = Trim$(CStr(idRaw))
    If NORMALIZE_ID_CASE Then s = UCase$(s)
    IdKeyOf = s
End Function

Private Function FindHeader(ByVal data As Variant, ByVal name As String) As Long
    Dim c As Long, target As String
    target = LCase$(name)
    For c = 1 To UBound(data, 2)
        If LCase$(Trim$(CStr(data(1, c)))) = target Then
            FindHeader = c
            Exit Function
        End If
    Next c
    FindHeader = 0
End Function

Private Function ComputePriority(ByVal linkedCount As Long, ByVal caseName As String, ByVal caseType As String) As Long
    Dim n As String, t As String
    n = UCase$(Trim$(caseName))
    t = Trim$(caseType)
    If linkedCount = 0 Then
        ComputePriority = 1
    ElseIf Left$(n, 3) = "INV" Then
        ComputePriority = 1
    ElseIf t = "Manual" Or t = "Parent" Then
        ComputePriority = 1
    Else
        ComputePriority = 0
    End If
End Function

Private Function ToExcelDate(ByVal v As Variant) As Double
    ' Excel serial, US M/D/Y h:mm AM/PM, ISO forms, returns 0 for missing or "Still Open"
    On Error GoTo FailSoft
    If IsEmpty(v) Or IsNull(v) Then GoTo FailSoft

    Dim rawU As String: rawU = Trim$(UCase$(CStr(v)))
    If rawU = "STILL OPEN" Or rawU = "OPEN" Then GoTo FailSoft

    If IsNumeric(v) Then
        Dim d As Double: d = CDbl(v)
        If d > 20000 And d < 100000 Then ToExcelDate = d: Exit Function
    End If

    Dim s As String: s = Trim$(CStr(v))
    If Len(s) = 0 Then GoTo FailSoft

    s = Replace(s, "T", " ")
    s = Replace(s, "Z", "")

    Dim sp As Long: sp = InStrRev(s, " ")
    If sp > 0 Then
        Dim tail As String: tail = Mid$(s, sp + 1)
        If Left$(tail, 1) = "+" Or Left$(tail, 1) = "-" Then s = Left$(s, sp - 1)
    End If

    If IsDate(s) Then ToExcelDate = CDbl(CDate(s)): Exit Function

    Dim datePart As String, timePart As String, hasTime As Boolean
    Dim p As Long: p = InStr(s, " ")
    If p > 0 Then datePart = Left$(s, p - 1): timePart = Mid$(s, p + 1): hasTime = True Else datePart = s: hasTime = False

    Dim parts() As String: parts = Split(datePart, "/")
    If UBound(parts) = 2 Then
        Dim m As Integer, dday As Integer, y As Integer
        m = Val(parts(0)): dday = Val(parts(1)): y = Val(parts(2))
        If y < 100 Then If y < 80 Then y = 2000 + y Else y = 1900 + y
        If m >= 1 And m <= 12 And dday >= 1 And dday <= 31 Then
            If hasTime Then ToExcelDate = CDbl(DateSerial(y, m, dday) + TimeValue(ParseTimeFlexible(timePart))) Else ToExcelDate = CDbl(DateSerial(y, m, dday))
            Exit Function
        End If
        If dday >= 1 And dday <= 12 And m >= 1 And m <= 31 Then
            If hasTime Then ToExcelDate = CDbl(DateSerial(y, dday, m) + TimeValue(ParseTimeFlexible(timePart))) Else ToExcelDate = CDbl(DateSerial(y, dday, m))
            Exit Function
        End If
    End If

FailSoft:
    ToExcelDate = 0
End Function

Private Function ParseTimeFlexible(ByVal s As String) As Date
    On Error GoTo Fallback
    s = Trim$(s)
    If s = "" Then ParseTimeFlexible = 0: Exit Function
    If InStr(s, ":") > 0 Then
        Dim firstCol As Long: firstCol = InStr(s, ":")
        Dim secondCol As Long: secondCol = InStr(firstCol + 1, s, ":")
        If secondCol = 0 Then ParseTimeFlexible = CDate(Left$(s, firstCol - 1) & ":" & Mid$(s, firstCol + 1) & ":00"): Exit Function
    End If
    If IsDate(s) Then ParseTimeFlexible = CDate(s): Exit Function
Fallback:
    ParseTimeFlexible = 0
End Function

' ---------- InputsStore, PersistStore, output ----------

Private Sub SnapshotAndMergeUserInputs(ByVal wsOut As Worksheet, ByRef dictInputs As Object)
    ' Read any existing D-F on Case Review List and merge into dictInputs by ID
    Dim lastRow As Long, r As Long, idDisp As String, idKey As String
    lastRow = wsOut.Cells(wsOut.Rows.Count, "A").End(xlUp).Row
    If lastRow < 2 Then Exit Sub

    For r = 2 To lastRow
        idDisp = CStr(wsOut.Cells(r, "A").Value)
        idKey = IdKeyOf(idDisp)
        If Len(idKey) = 0 Then GoTo NextR

        Dim sr As String, det As String, note As String
        sr = CStr(wsOut.Cells(r, "D").Value)
        det = CStr(wsOut.Cells(r, "E").Value)
        note = CStr(wsOut.Cells(r, "F").Value)

        If Len(sr) > 0 Or Len(det) > 0 Or Len(note) > 0 Then
            dictInputs(idKey) = Array(sr, det, note, CDbl(Now))
        End If
NextR:
    Next r
End Sub

Private Function LoadInputsStore() As Object
    Dim ws As Worksheet, lo As ListObject, dict As Object
    Set dict = CreateObject("Scripting.Dictionary")
    Set ws = SheetByName("InputsStore")

    On Error Resume Next
    Set lo = ws.ListObjects("T_Inputs")
    On Error GoTo 0

    If lo Is Nothing Then
        ws.Cells.Clear
        ws.Range("A1:D1").Value = Array("XSOAR_ID", "SeniorReviewer", "Determination", "Notes")
        Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range("A1:D1"), , xlYes)
        lo.Name = "T_Inputs"
        ws.Visible = xlSheetVeryHidden
        Set LoadInputsStore = dict
        Exit Function
    End If

    If lo.DataBodyRange Is Nothing Then
        ws.Visible = xlSheetVeryHidden
        Set LoadInputsStore = dict
        Exit Function
    End If

    Dim arr As Variant, r As Long, idKey As String
    arr = lo.DataBodyRange.Value2
    For r = 1 To UBound(arr, 1)
        idKey = IdKeyOf(CStr(arr(r, 1)))
        If Len(idKey) > 0 Then dict(IdKeyOf(arr(r, 1))) = Array(CStr(arr(r, 2)), CStr(arr(r, 3)), CStr(arr(r, 4)), 0#)
    Next r

    ws.Visible = xlSheetVeryHidden
    Set LoadInputsStore = dict
End Function

Private Sub SaveInputsStore(ByVal dictInputs As Object)
    Dim ws As Worksheet, lo As ListObject
    Set ws = SheetByName("InputsStore")

    On Error Resume Next
    Set lo = ws.ListObjects("T_Inputs")
    On Error GoTo 0

    If lo Is Nothing Then
        ws.Cells.Clear
        ws.Range("A1:D1").Value = Array("XSOAR_ID", "SeniorReviewer", "Determination", "Notes")
        Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range("A1:D1"), , xlYes)
        lo.Name = "T_Inputs"
    End If

    If Not lo.DataBodyRange Is Nothing Then lo.DataBodyRange.Delete

    Dim n As Long, k As Variant, outArr() As Variant, i As Long
    n = dictInputs.Count
    If n > 0 Then
        ReDim outArr(1 To n, 1 To 4)
        i = 1
        For Each k In dictInputs.Keys
            Dim rec() As Variant
            rec = dictInputs(k)
            ' rec: SR, Det, Notes, UpdatedAt
            outArr(i, 1) = CStr(k)       ' store key as written, which may be upper if NORMALIZE_ID_CASE True
            outArr(i, 2) = rec(0)
            outArr(i, 3) = rec(1)
            outArr(i, 4) = rec(2)
            i = i + 1
        Next k
        lo.Resize ws.Range("A1").Resize(n + 1, 4)
        lo.DataBodyRange.Value = outArr
    Else
        lo.Resize ws.Range("A1:D1")
    End If

    ws.Visible = xlSheetVeryHidden
End Sub

Private Function LoadPersistStore() As Object
    Dim ws As Worksheet, lo As ListObject, dict As Object
    Set dict = CreateObject("Scripting.Dictionary")

    Set ws = SheetByName("PersistStore")
    On Error Resume Next
    Set lo = ws.ListObjects("T_Persist")
    On Error GoTo 0

    If lo Is Nothing Then
        ws.Cells.Clear
        ws.Range("A1:E1").Value = Array("XSOAR_ID_Display", "Case Owner", "Manager of Case Owner", "PriorityFlag", "ClosedSerial")
        Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range("A1:E1"), , xlYes)
        lo.Name = "T_Persist"
        ws.Visible = xlSheetVeryHidden
        Set LoadPersistStore = dict
        Exit Function
    End If

    If lo.DataBodyRange Is Nothing Then
        ws.Visible = xlSheetVeryHidden
        Set LoadPersistStore = dict
        Exit Function
    End If

    Dim arr As Variant, r As Long, idKey As String
    arr = lo.DataBodyRange.Value2
    For r = 1 To UBound(arr, 1)
        idKey = IdKeyOf(CStr(arr(r, 1))) ' we stored display in col A for legacy, key off it
        If Len(idKey) > 0 Then
            dict(idKey) = Array(CStr(arr(r, 1)), CStr(arr(r, 2)), CStr(arr(r, 3)), CLng(arr(r, 4)), CDbl(arr(r, 5)))
        End If
    Next r

    ws.Visible = xlSheetVeryHidden
    Set LoadPersistStore = dict
End Function

Private Sub SavePersistStore(ByVal dictPersist As Object)
    Dim ws As Worksheet, lo As ListObject
    Set ws = SheetByName("PersistStore")

    On Error Resume Next
    Set lo = ws.ListObjects("T_Persist")
    On Error GoTo 0

    If lo Is Nothing Then
        ws.Cells.Clear
        ws.Range("A1:E1").Value = Array("XSOAR_ID_Display", "Case Owner", "Manager of Case Owner", "PriorityFlag", "ClosedSerial")
        Set lo = ws.ListObjects.Add(xlSrcRange, ws.Range("A1:E1"), , xlYes)
        lo.Name = "T_Persist"
    End If

    If Not lo.DataBodyRange Is Nothing Then lo.DataBodyRange.Delete

    Dim n As Long, k As Variant, outArr() As Variant, i As Long
    n = dictPersist.Count
    If n > 0 Then
        ReDim outArr(1 To n, 1 To 5)
        i = 1
        For Each k In dictPersist.Keys
            Dim rec() As Variant
            rec = dictPersist(k)
            ' rec: displayId, owner, mgr, prio, closedSerial
            outArr(i, 1) = rec(0)
            outArr(i, 2) = rec(1)
            outArr(i, 3) = rec(2)
            outArr(i, 4) = CLng(rec(3))
            outArr(i, 5) = CDbl(rec(4))
            i = i + 1
        Next k
        lo.Resize ws.Range("A1").Resize(n + 1, 5)
        lo.DataBodyRange.Value = outArr
    Else
        lo.Resize ws.Range("A1:E1")
    End If

    ws.Visible = xlSheetVeryHidden
End Sub

Private Sub WriteOutputFromPersist(ByVal wsOut As Worksheet, ByVal dictPersist As Object, ByVal dictInputs As Object)
    ' Headers, include visible Closed Date
    wsOut.Rows(1).ClearContents
    wsOut.Range("A1").Resize(1, 8).Value = Array( _
        "XSOAR_ID", "Case Owner", "Manager of Case Owner", _
        "Senior Reviewer", "Determination", "Notes", "PriorityFlag", "Closed Date/Time (UTC)" _
    )

    ' Clear body values only
    If wsOut.UsedRange.Rows.Count > 1 Then wsOut.Rows("2:" & wsOut.Rows.Count).ClearContents

    ' Collect keys excluding Dbot manager
    Dim keys As Collection, k As Variant, rec() As Variant
    Set keys = New Collection
    For Each k In dictPersist.Keys
        rec = dictPersist(k)
        If UCase$(Trim$(CStr(rec(2)))) <> "DBOT" Then keys.Add k
    Next k

    Dim n As Long: n = keys.Count
    If n = 0 Then Exit Sub

    Dim outArr() As Variant, tmpClosed() As Double
    ReDim outArr(1 To n, 1 To 8)
    ReDim tmpClosed(1 To n, 1 To 1)

    Dim i As Long, idKey As String, dispId As String, inp() As Variant
    i = 1
    For Each k In keys
        rec = dictPersist(k) ' displayId, owner, mgr, prio, closedSerial
        idKey = CStr(k)
        dispId = CStr(rec(0))

        outArr(i, 1) = dispId                          ' XSOAR_ID
        outArr(i, 2) = rec(1)                          ' Case Owner
        outArr(i, 3) = rec(2)                          ' Manager of Case Owner
        ' D-F restored below from dictInputs
        outArr(i, 7) = rec(3)                          ' PriorityFlag

        If CDbl(rec(4)) = 0 Then outArr(i, 8) = "" Else outArr(i, 8) = CDbl(rec(4))
        tmpClosed(i, 1) = CDbl(rec(4))
        i = i + 1
    Next k

    wsOut.Range("A2").Resize(n, 8).Value = outArr

    ' Sort by Priority desc, then Closed desc
    wsOut.Range("I1").Value = "ClosedSerial_tmp"
    wsOut.Range("I2").Resize(n, 1).Value = tmpClosed
    With wsOut.Sort
        .SortFields.Clear
        .SortFields.Add Key:=wsOut.Range("G2:G" & n + 1), SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortNormal
        .SortFields.Add Key:=wsOut.Range("I2:I" & n + 1), SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortNormal
        .SetRange wsOut.Range("A1:I" & n + 1)
        .Header = xlYes
        .Apply
    End With
    wsOut.Columns("I").EntireColumn.Hidden = True

    ' Restore user inputs D-F from dictInputs by ID
    Dim lastRow As Long, r As Long, idDisp As String
    lastRow = wsOut.Cells(wsOut.Rows.Count, "A").End(xlUp).Row
    For r = 2 To lastRow
        idDisp = CStr(wsOut.Cells(r, "A").Value)
        idKey = IdKeyOf(idDisp)
        If dictInputs.Exists(idKey) Then
            inp = dictInputs(idKey) ' SR, Det, Notes, UpdatedAt
            wsOut.Cells(r, "D").Value = inp(0)
            wsOut.Cells(r, "E").Value = inp(1)
            wsOut.Cells(r, "F").Value = inp(2)
        End If
    Next r
End Sub

' ---------- Utilities ----------

Private Function SheetByName(ByVal nm As String) As Worksheet
    On Error Resume Next
    Set SheetByName = ThisWorkbook.Worksheets(nm)
    On Error GoTo 0
    If SheetByName Is Nothing Then
        Set SheetByName = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
        SheetByName.Name = nm
    End If
End Function
